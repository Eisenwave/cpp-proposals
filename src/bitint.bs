<pre class='metadata'>
Title: <code>Bit-precise integers</code>
Shortname: Pxxxx
Revision: 0
Status: NP
Date: 2025-02-15
Group: WG21
Audience: LEWGI, LEWG, EWGI, EWG
Editor: Jan Schultke, janschultke@gmail.com
!Source: [eisenwave/cpp-proposals](https://github.com/Eisenwave/cpp-proposals/blob/master/src/bitint.bs)
Markup Shorthands: markdown on
Abstract: This paper incorporates the bit-precise integers from C23 into the C++ standard.
</pre>

# Introduction # {#overview}

[[N2763]] has introduced bit-precise integers into C23, in the form of a new `_BitInt(N)`
integer type.
[[N2775]] subsequently added the `wb` integer literal suffix for these types.

Such integers have two notable advantages over the standard integers provided in C++:
1. They can have an arbitrary (but constant, and up to a certain limit) width.
2. They are not subject to the usual integer promotion rules.

# Motivation # {#motivation}

## C compatibility ## {#motivation-c-compatibilty}

There is currently no standard way to pass or receive what is a `_BitInt` type on the C side.
Consider the following C code:

```cpp
void f(_BitInt(/* ... */));
```
How would a C++ program portably call such as a C function?
For specific widths of `_BitInt`, this may be possible,
but certainly not once the width of `long long` is exceeded.

## Hardware representation ## {#hardware-representation}

As [[N2763]] motivates, arbitrary precision integers are useful for representing
hardware types.
Certain applications involving FPGAs use up to 2031-bit integers.
To utilize these hardware capabilities, C++ needs an integer type that can represent them.

## Large-width computations ## {#motivation-large-width-computations}

Certain applications require much greater integer widths than the standard integers in C++ can provide.
For example, RSA and other cryptosystems may use `_BitInt(4096)` or wider.

# Design Considerations # {#design-considerations}

We pursue the following design goals:
- Provide a type with zero overhead (compared to C's `_BitInt`).
- Prioritize safety and ease of use over similarity with fundamental integers.
- Prioritize design quality in C++ over interoperability with C.

## Why not a fundamental type? ## {#why-not-a-fundamental-type}

The most notable design decision is to provide a library `std::bit_int` type,
rather than exposing a `_BitInt` fundamental type.

*Why?* Because it's possible, and all prior art in C++ makes this design choice.
C's `complex float` is `std::complex<float>`, and `_Atomic` is `std::atomic`.
Furthermore, it's much easier for C++ users to learn a library type
(if they feel the need to use it)
than to learn an entirely new set of integer types, with distinct behavior.

### Drastic library impact ### {#drastic-library-impact}

At the very least, the following parts of the core language would be impacted:

- Promotion and conversions rules.
- Deduction of `N` from `_BitInt(N)` in templates.
- Overload resolution with bit-precise integers.

Furthermore, bit-precise integers may be a valid choice for the result of `sizeof`,
pointer differences, `size_type`s in the library, and many more implementation choices.

### ABI Break ### {#abi-break}

The introduction of new integers, even if they are not standard integers,
would currently break ABI.
This is due to the fact that say, `_BitInt(128)` would bump up the
corresponding `difference_type` of `std::ranges::iota_view`.

### Drastic library impact ### {#drastic-library-impact}

Furthermore, if these new types are considered integral types,
every part of the library that is said to take integers
(`<bit>`, `<cmath>`, `<format>`, and many more) would need to be implemented
for N-bit integers out of a sudden, or reworded to not accept them, case-by-case.

### `_BitInt` is an enhancement, not a replacement ### {#enhancement-not-replacement}

The drastic changes above are a seemingly pointless endavour
considering that C's `_BitInt` is not a
complete replacement for the standard integers anyway.
For example, `123wb8 + 0` (where `123wb8` is of type `_BitInt(8)`) is of type `int`.
The standard integers generally win in conversions, and `_BitInt` is an
enhancement, not a replacement.
This is the role between a C++ library type as well.

I have heard many people express that they would like `_BitInt`
to "fix and replace" the "old integers", but this would require deviating
in our design from C's.
It seems unrealistic for C++ to have a different fundamental `_BitInt` from C.

## Problems and solutions ## {#problems-and-solutions}

### Type trait changes ### {#type-trait-changes}

**Problem:** Changing the meaning of some type traits would impact existing code.
If we were to change the result of `std::is_integral_v` and other traits
so that `std::bit_int` is accepted, this would suddenly underconstrain
any existing code.

This is quite a big issue because a user expects that integers can be fed into
many library parts that would not support `std::bit_int`.
Even `std::make_unsigned_t` could be used in a return type for the purpose of SFINAE.

**Solution:**
For now, we remain conservative and don't broaden any type traits.
`std::is_integral_v<std::atomic_int>` is `false`,
so why should this design be any different for `std::bit_int`?
The user can trivially define traits that handle `std::bit_int` themselves.


### C compatibilty macros ### {#c-compatibility-macros}

**Problem:** Neither the spelling `_BitInt` nor `std::bit_int` can be used
in both languages, making it difficult to interop between C and C++.

**Solution:** Similar to `_Atomic(type)`, which is
- a type specifier in C, or
- a macro which expands to `std::atomic<type>` in C++,

we introduce the `_BitInt` and `_BitUint` compatibility macros:

```cpp
#ifdef __cplusplus
// note: don't define _BitInt if it's a compiler-intrinsic already
#define _BitInt(...) ::std::bit_int<(__VA_ARGS__)>
#define _BitUint(...) ::std::bit_int<(__VA_ARGS__)>
#else
// _BitInt is a keyword in C, so don't attempt to define it
#define _BitUint(...) typeof(unsigned _BitInt(__VA_ARGS__))
#endif
```

Unfortunately, `unsigned _BitInt(32)` would not be valid in C++ even with such macros
because `unsigned` cannot be combined with class types.
This is a sacrifice we are willing to make, and it's only relevant to C/C++ interoperable code anyway,
which is typically limited to header files.

### Concerns regarding overload resolution ### {#concerns-regarding-overload-resolution}

**Problem:** With a class type, certain forms of overload resolution cannot be easily facilitated:
```cpp
void foo(std::bit_int<32>);
void foo(std::bit_int<16>);
foo(std::bit_int<8>(0)); // should call foo(std::bit_int<16>), but is ambiguous
```

**Solution:** None.
However, this is not a novel problem.
This existing code is also ill-formed:
```cpp
void foo(long);
void foo(long long);
foo(0); // error: ambiguous
```

## Obtaining the width ## {#width}

**Problem:** If we are not deducing the width of a `std::bit_int`,
we may still want to access it.

**Solution:** We propose a long overdue addition:
`std::numeric_limits<T>::width`, which would yield the width of an integer.
Note that `digits` instead returns the maximum representible digits,
which would be `31` for a 32-bit integer signed integer; this is not the *width*.

## Conversion to bit_int ## {#to-bit-int}

**Problem:**
It is often desirable to implement numeric functions using `std::bit_int`,
but provide an interface that (also or exclusively) accepts integral types.
For example, say we wanted `std::popcount` to accept both integral types and `std::bit_int`.
Then, an implementation may look as follows:
```cpp
template </* unsigned integral or bit_uint */ T>

```

```cpp
template <typename T>
std::bit_int<std::numeric_limits<T>::width> to_bit_int(const T& x);
```

# Impact on the standard # {#impact-on-the-standard}

The core language is unaffected.

The library impact consist of:
- Adding the class template `std::bit_int`
- Adding the compatibility macros `_BitInt` and `_BitUint`
- Adding partial specializations of various type traits.

# Implementation experience # {#implementation-experience}

Clang makes the following implementation possible in C++, on any target:
```cpp
template <size_t N>
class bit_int {
private:
    _BitInt(N) _M_value;
public:
    // ...
}
```

Note: `bit_uint` would be implemented analogously,
just with `unsigned _BitInt` as the internal value.

This is the ideal implementation because it
- easily achieves ABI-compatibility with C,
- bypasses the optimization limitations that a pure library implementation would have, and
- instantiates very little C++ code.

A pure library implementation is also possible; see Boost.Multiprecision.

The remaining proposed compatibilty macros and minor changes are obviously implementable,
and sample implementations are provided in this proposal.


# Proposed wording # {#proposed-wording}

The wording is relative to [[!N5001]].

<pre class=biblio>
{
    "N2763": {
        "authors": ["Aaron Ballman, Melanie Blower, Tommy Hoffner, Erich Keane"],
        "href": "https://open-std.org/JTC1/SC22/WG14/www/docs/n2763.pdf",
        "title": "Adding a Fundamental Type for N-bit integers",
        "publisher": "WG14"
    }
}
</pre>