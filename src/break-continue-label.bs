<pre class='metadata'>
Title: <code>break label;</code> and <code>continue label;</code>
Shortname: Dxxxx
Revision: 0
Status: D
Date: 2024-12-18
Group: WG21
Audience: SG22, LEWGI, LEWG
Editor: Jan Schultke, janschultke@gmail.com
Editor: Sarah Qui√±ones
ED: https://eisenwave.github.io/cpp-proposals/break-continue-label.html
!Source: [eisenwave/cpp-proposals](https://github.com/Eisenwave/cpp-proposals/blob/master/src/break-continue-label.bs)
Markup Shorthands: markdown on
Abstract: Introduce `break label` and `continue label` to `break` and `continue`
          out of nested loops and `switch`es, as accepted into C2y.
</pre>

# Revision history # {#history}

This is the first revision.

# Introduction # {#introduction}

While C++ already has a broad selection of control flow constructs,
one construct commonly found in other languages is notably absent:
the ability to apply `break` or `continue` to a loop or `switch` when
this isn't the innermost enclosing statement.
This feature is popular, simple, and quite useful:

Specifically, we propose the following syntax:
```cpp
outer: for (auto x : xs) {
    for (auto y : ys) {
        if (/* ... */) {
            continue outer; // OK, continue applies to outer for loop
            break outer;    // OK, break applies to outer for loop  
        }
    }
}

switch_label: switch (/* ... */) {
    default: while (true) {
        if (/* ...*/) {
            break switch_label; // OK, break applies to switch, not to while loop
        }
    }
}

break outer; // error: cannot break loop from the outside
goto outer; // OK, used to be OK, and is unaffected by this proposal
```

This syntax, identical to that in [[N3355]] has been accepted into C2y.
This proposal brings that syntax into C++ and relaxes restrictions on labels to
make it more powerful and to address concerns in a rival proposal [[N3377]].

As for C++, `break` and `continue` with labels have been proposed in [[N3879]]
and rejected at Rapperswil 2014 ([[N4327]]):

<blockquote>
<p>Straw poll, proposal as a whole:</p>
<table>
<tr>
    <td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td>
</tr>
<tr>
    <td>1</td><td>1</td><td>1</td><td>13</td><td>10</td>
</tr>
</table>
<p>"break label;" + "continue label;"</p>
<table>
<tr>
    <td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td>
</tr>
<tr>
    <td>3</td><td>8</td><td>4</td><td>9</td><td>3</td>
</tr>
</table>
</blockquote>

Ten years later, circumstances have changed and we should re-examine this feature.

## What has changed since 2014 ## {#changes-since-2014}

Use of `constexpr` has become tremendously more common,
and `goto` may not be used in constant expressions.
Where `goto` is used to break out of nested loops, `break label` makes it easy to migrate code:

<div class="example">
Uses of `goto` to break out of nested loops can be replaced with `break label` as follows:

<pre><code>
<ins>constexpr</ins> void f() {
    <ins>outer: </ins>while (/* ... */) {
        while (/* ... */) {
            if (/* ... */) {
                <del>goto after_loop;</del>
                <ins>break outer;</ins>
            }
        }
    }
    <del>after_loop:;</del>
}
</code></pre>
</div>

Besides this change in C++, `break label` and `continue label` have seen an increase
in popularity over the last ten years.
The feature has seen increased adoption in older languages such as C and JavaScript,
and newer languages have been popularized which support this construct,
such as Rust and Kotlin.


# Motivation # {#motivation}

`break label` and `continue label` are largely motivated by the ability to control nested loops.
This is a highly popular feature in other languages,
and C++ could use it too, since it has no good alternative.

## No good alternative ## {#no-good-alternatives}

Let's examine a motivating example which uses our new construct:

<div class="example">

```cpp
void f() {
    process_files: for (const File& text_file : files) {
        for (std::string_view line : text_file.lines()) {
            if (makes_me_angry(line)) {
                continue process_files;
            }
            consume(line);
        }
        std::println("Processed {}", text_file.path());
    }
    std::println("Processed all files");
}
```

`continue label` is very useful in this scenario,
and expresses our intent with unparalleled clarity.
We want to continue processing other files, so we `continue process_files`.

A plain `break` cannot be used here because it would result in executing the
following `std::println` statement, but this should only be done upon success. 
</div>

There are alternative ways to write this, but all of them have some form of issues:

### `goto` ### {#alternative-goto}

```cpp
for (const File& text_file : files) {
    for (std::string_view line : text_file.lines()) {
        if (makes_me_angry(line)) {
            goto done_with_file;
        }
        consume(line);
    }
    std::println("Processed {}", text_file.path());
    done_with_file:
}
std::println("Processed all files");
```

`goto` is similar in complexity and even readability here, however there are some issues:

- `goto` cannot cross (non-vacuous) initialization,
    which would be an issue if some variable was initialized prior to `std::println`.
    This can be addressed by surrounding the outer loop contents with another set of braces,
    but this solution isn't obvious and takes away from the elegance of `goto` here.
- `goto` cannot be used in constant expressions.
    For processing text files like in the example, this doesn't matter,
    but nested loops are desirable in a `constexpr` context as well.
- Many style guides ban or discourage the use of `goto`.
    See [[MISRA-C++]], [[CppCoreGuidelinesES76]], etc.
    This discouragement dates all the way back to 1968 (see [[GotoConsideredHarmful]]),
    and 66 years of teaching not to use `goto` won't be undone.
- Even in the cases where `goto` isn't discouraged,
    those cases are always special, like "only `goto` forwards",
    "only `goto` to break out of loops", etc..
    This issue has been debated for decades,
    and there is still no consensus on when, actually, `goto` is okay to use.
- `goto` is innately more difficult to use because to understand its purpose,
    the user has to know where the jump target is located.
    A `goto past_the_loop` behaves radically differently compared to a `goto before_the_loop`.
    Moving the jump target or the `goto` statement relative to each other can also completely
    change these semantics.
    By comparison, `break` and `continue` always jump forwards,
    past a surrounding loop, or to the end of a surrounding loop respectively,
    making them much easier to reason about, and much less error-prone.
- The "local readability" of `goto` relies heavily on high-quality naming for the label.
    A `goto end` could mean to the end of a loop, to after the loop, to the end of a function, etc.
    Since `break` and `continue` are much more limited,
    they do not require such good label naming.
    A `break loop` has bad name, but the user *generally* understands its purpose.

Note: Previous discussion on the [[isocpp-core]] reflector has addressed the idea
of just adding `constexpr goto`,
but doing so is alleged to be more complicated than more limited `constexpr` control flow
structures which can only "jump forwards", such as `break` and `continue`.

In conclusion, there are too many issues with `goto`, some of which may never be resolved.
`std-proposals` discussion prior to the publication of this proposal has shown once again
that `goto` is a controversial and divisive.

### Immediately invoked lambda expression (IILE) ### {#alternative-iile}

```cpp
for (const File& text_file : files) {
    [&] {
        for (std::string_view line : text_file.lines()) {
            if (makes_me_angry(line)) {
                return;
            }
            consume(line);
        }
        std::println("Processed {}", text_file.path());
    }();
}
std::println("Processed all files");
```

While this solution works in constant expressions,
we may be painting ourselves into a corner with this design.
We cannot also `break` the surrounding loop from within the IILE,
and we cannot return from the surrounding function.
If this is needed at some point, we will have to put substantial effort into refactoring.

Furthermore, this solution isn't exactly elegant:

- The level of indentation has unnecessarily increased through the extra scope.
- The call stack will be one level deeper during debugging.
    This may be relevant to debug build performance.
- The fact that the lambda is immediately invoked isn't obvious until reading up to `()`.
- The word `return` does not express the overall intent well, which is merely to
    continue the outer loop.
    This can be considered a teachability downside.

It is also possible to use an additional function instead of an IILE in this place.
However, this is arguably increasing the degree of complexity even more,
and it scatters the code across multiple functions without any substantial benefit.

### Mutable `bool` state ### {#alternative-bool-state}

```cpp
for (const File& text_file : files) {
    bool success = true;
    for (std::string_view line : text_file.lines()) {
        if (makes_me_angry(line)) {
            success = false;
            break;
        }
        consume(line);
    }
    if (success) {
        std::println("Processed {}", text_file.path());
    }
}
std::println("Processed all files");
```

This solution substantially increase complexity.
Instead of introducing extra scope and call stack depth,
we add more mutable state to our function.
The original intent of "go process the next file" is also lost.

Such a solution also needs additional state for each nested loop,
i.e. two `bool`s are needed to `continue` from a loop "two levels up".

## Argumentum ad populum ## {#argumentum-ad-populum}

Another reason to have `break label` and `continue label` is simply that it's a
popular construct, available in other languages.
When Java, JavaScript, Rust, or Kotlin developers pick up C++,
they may expect that C++ can `break` out of nested loops as well,
but will find themselves disappointed.

[[StackOverflow]] <i>"Can I use break to exit multiple nested `for` loops?"</i>
shows that there is interest in this feature (393K views at the time of writing).

### Poll ### {#poll}

Another way to measure interest is to simply ask C++ users.
The following is a committee-style poll (source: [[TCCPP]]) from the Discord server
[Together C & C++](https://discord.gg/tccpp),
which is the largest server in terms of C++-focused message activity:

<blockquote>
Should C++ have "break label" and "continue label" statements
to apply break/continue to nested loops or switches?

<table>
<tr>
    <td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td>
</tr>
<tr>
    <td>21</td><td>21</td><td>12</td><td>6</td><td>4</td>
</tr>
</table>
</blockquote>

Note: 64 users in total voted, and the poll was active for one week.

### How common is `break`/`continue` with labels? ### {#how-common-is-break-continue-label}

To further quantify the popularity, we can use GitHub code search for various
languages which already support this feature.
The following table counts only control statements with a label,
*not* plain `break;`, `continue;`, etc.

<table>
    <tr>
        <td>Language</td>
        <td>Syntax</td>
        <td>Labeled<br>`break`s</td>
        <td>Labeled<br>`continue`s</td>
        <td>&Sigma; `break` `continue`</td>
        <td>`goto`s</td>
    </tr>
    <tr>
        <td>Java</td>
        <td>`label: for (...)`<br>`break label;`<br>`continue label;`</td>
        <td><a href="https://github.com/search?q=language%3AJava+%2F%28%3F-i%29break+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">424K files</a></td>
        <td><a href="https://github.com/search?q=language%3AJava+%2F%28%3F-i%29continue+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">152K files</a></td>
        <td>576K files</td>
        <td>N/A</td>
    </tr>
    <tr>
        <td>JavaScript</td>
        <td>`label: for (...)`<br>`break label;`<br>`continue label;`</td>
        <td><a href="https://github.com/search?q=language%3AJavaScript+%2F%28%3F-i%29break+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">53.8K files</a></td>
        <td><a href="https://github.com/search?q=language%3AJavaScript+%2F%28%3F-i%29continue+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">68.7K files</a></td>
        <td>122.5K files</td>
        <td>N/A</td>
    </tr>
    <tr>
        <td>Perl</td>
        <td>`label: for (...)`<br>`last label;`<br>`next label;`</td>
        <td><a href="https://github.com/search?q=language%3APerl+%2F%28%3F-i%29last+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">34.9K files</a></td>
        <td><a href="https://github.com/search?q=language%3APerl+%2F%28%3F-i%29next+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">31.7K files</a></td>
        <td>66.6K files</td>
        <td><a href="https://github.com/search?q=language%3APerl+%2F%28%3F-i%29goto+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">16.9K files</a></td>
    </tr>
    <tr>
        <td>Rust</td>
        <td>`label: for (...)`<br>`break 'label;`<br>`continue 'label;`</td>
        <td><a href="https://github.com/search?q=language%3ARust+%2F%28%3F-i%29break+%3F%27%5Ba-zA-Z0-9%5D%2B%3B%2F&type=code">30.6K files</a></td>
        <td><a href="https://github.com/search?q=language%3ARust+%2F%28%3F-i%29continue+%3F%27%5Ba-zA-Z0-9%5D%2B%3B%2F&type=code">29.1K files</a></td>
        <td>59.7K files</td>
        <td>N/A</td>
    </tr>
    <tr>
        <td>TypeScript</td>
        <td>`label: for (...)`<br>`break label;`<br>`continue label;`</td>
        <td><a href="https://github.com/search?q=language%3ATypeScript+%2F%28%3F-i%29break+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">11.6K files</a></td>
        <td><a href="https://github.com/search?q=language%3ATypeScript+%2F%28%3F-i%29continue+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">9K files</a></td>
        <td>20.6K files</td>
        <td>N/A</td>
    </tr>
    <tr>
        <td>Swift</td>
        <td>`label: for ...`<br>`break label`<br>`continue label`</td>
        <td><a href="https://github.com/search?q=language%3ASwift+%2F%28%3F-i%29break+%5B_a-zA-Z0-9%5D%2B%5Cn%2F&type=code">12.6K files</a></td>
        <td><a href="https://github.com/search?q=language%3ASwift+%2F%28%3F-i%29continue+%5B_a-zA-Z0-9%5D%2B%5Cn%2F&type=code">5.6K files</a></td>
        <td>18.2K files</td>
        <td>N/A</td>
    </tr>
    <tr>
        <td>Kotlin</td>
        <td>`label@ for (...)`<br>`break@label`<br>`continue@label`</td>
        <td><a href="https://github.com/search?q=language%3AKotlin+%2F%28%3F-i%29break%40%5B_a-zA-Z0-9%5D%2B%2F&type=code">8.7K files</a></td>
        <td><a href="https://github.com/search?q=language%3AKotlin+%2F%28%3F-i%29continue%40%5B_a-zA-Z0-9%5D%2B%2F&type=code">7.6K files</a></td>
        <td>16.3K files</td>
        <td>N/A</td>
    </tr>
    <tr>
        <td>D</td>
        <td>`label: for (...)`<br>`break label;`<br>`continue label;`</td>
        <td><a href="https://github.com/search?q=language%3AD+%2F%28%3F-i%29break+%5Ba-zA-Z0-9%5D%2B%3B%2F&type=code">3.5K files</a></td>
        <td><a href="https://github.com/search?q=language%3AD+%2F%28%3F-i%29continue+%5Ba-zA-Z0-9%5D%2B%3B%2F&type=code">2.6K files</a></td>
        <td>6.1K files</td>
        <td><a href="https://github.com/search?q=language%3AD+%2F%28%3F-i%29goto+%5Ba-zA-Z0-9%5D%2B%3B%2F&type=code">12.3K files</a></td>
    </tr>
    <tr>
        <td>Go</td>
        <td>`label: for ...`<br>`break label;`<br>`continue label;`</td>
        <td><a href="https://github.com/search?q=language%3AGo+%2F%28%3F-i%29break+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">270 files</a></td>
        <td><a href="https://github.com/search?q=language%3AGo+%2F%28%3F-i%29continue+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">252 files</a></td>
        <td>522</td>
        <td><a href="https://github.com/search?q=language%3AD+%2F%28%3F-i%29goto+%5Ba-zA-Z0-9%5D%2B%3B%2F&type=code">1.5K files</a></td>
    </tr>
    <tr>
        <td>C</td>
        <td>`label: for (...)`<br>`break label;`<br>`continue label;`</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td><a href="https://github.com/search?q=language%3AC+%2F%28%3F-i%29goto+%5B_a-zA-Z0-9%5D%2B%3B%2F&type=code">7.8M files</a></td>
    </tr>
</table>


Based on this, we can reasonably estimate that there are at least one million files
in the world which use labeled `break`/`continue` (or an equivalent construct).

Note: The `break` and `continue` columns also count equivalent constructs, such as Perl's `last`.

Note: This language list is not exhaustive and the search only includes open-source code bases on GitHub.

Note: The D `goto` count is inflated by `goto case;` and `goto default;`
which perform `switch` fallthrough.

Note: Fun fact: `continue` occurs in
<a href="https://github.com/search?q=language%3AC+%2F%28%3F-i%29continue%3B%2F&type=code">5.8M C files</a>,
meaning that `goto` is more common.


## C2y compatibility ## {#c2y-compatibility}

Last but not least, C++ should have `break label` and `continue label`
to increase the amount of code that has a direct equivalent in C.
Such compatibility is desirable for two reasons:

- `inline` functions or macros used in C/C++ interoperable headers could use the same syntax.
- C2y code is much easier to port to C++ (and vice-versa) if both languages support the same
    control flow constructs.

Furthermore, the adoption of [[N3355]] saves EWG a substantial amount of time
when it comes to debating the syntax; the C++ syntax should certainly be C-compatible.

Note: The [[N3355]] syntax is still subject to discussion; see [[#syntax]].


# Design Considerations # {#design-considerations}

## Why not `break N;`? ## {#why-not-break-n}

A possible alternative to `break label;` would be a `break N;` syntax
(analogous for `continue`),
where `N` is an *integer-literal* or *constant-expression* which specifies
how many levels should be broken.
For example:

```cpp
while (/* ... */)
    while (/* ...*/)
        break 2; // breaks both loops
```

We don't propose this syntax for multiple reasons.
Firstly,
[[N3355]] points out readability concerns, concerns when using `break N;` in a macro,
and these are valid concerns in C++ as well.

Secondly, `break N` is more challenging to read because the developer has to investigate what scopes
surround the statement (where e.g. `if` doesn't count, but `switch` and `for` count),
and conclude from this where `break` applies.
By comparison, `break label;` obviously breaks out of the loop labeled `label:`.

Thirdly, this construct is an obscure idea (not entirely novel, seen before in PHP).
It is similar to `break statement;` proposed in [[P2635R0]].
The author has seemingly abandoned that proposal.
In our experience, obscure control flow ideas are unpopular and not worth pursuing.
An extreme negative reaction to obscure control flow ideas was seen for
the `goto default;` and `goto case X;` statements proposed in [[N3879]].
By comparison, `break label;` is completely mainstream;
such code has likely been written a million times or more already
(based on numbers in [[#how-common-is-break-continue-label]]).

Last but not least, this syntax would be incompatible with the C2y construct,
and so it would need to be
overwhelmingly, tremendously, titanically superior compared to `break label;`,
so that tossing compatibility aside could be justified.
It obviously doesn't meet this hurdle.

## Why not `break while;` et al.? ## {#why-not-break-while}

Yet another novel idea has been suggested at [[std-proposals-2]]:
```cpp
while (/* ... */) {
 for (/* ... */) {
   if (/* ... */) {
     break while; // break the while loop, not the for loop
     // break for while; // identical in functioning to the above version
    }
  }
}
```
This idea has been received negatively, and we strongly oppose it.
It is not as obvious what the targeted statement is, as with `break N;`,
and code can easily be broken by relocating the `break for while for;`
or whatever statement somewhere else.

Additionally, just like `break N;`, it is C2y-incompatible and so not worth pursuing.

## What about `break label;` for block statements etc.? ## {#break-block-statement} 

The following is *not* proposed:
```cpp
label: {
    break label;
}
```

Being able to apply `break` or `continue` to additional constructs in C++ would be a
controversial and novel idea.
We simply want to apply `break` and `continue` to the same things you can already apply it to,
but also state *which* construct they apply to, if need be.

## Should there be `break label;` and `continue label;` in constant expressions? ## {#constexpr-break-continue}

Yes, absolutely!
This is a major benefit over `goto`, and part of the motivation for this proposal.

An implementation is also quite feasible, and *basically* already exists in every compiler.
For constant evaluation, `break` already needs to be able to exit
out of arbitrarily deeply nested scopes:

```cpp
while (/* ... */) {
    if (/* ... */) {
        { { { { { break; } } } } }
    }
}
```

The only novelty offered by `break label;` is that one of those nested, exited scopes may also be
a `switch` or loop, which is not substantially challenging for implementers.


## What about syntax? ## {#syntax}

We strongly support the currently accepted syntax of [[N3355]].
This syntax is
- simple and intuitive,
- has been used in a variety of other languages, and
- is easy to implement, considering that labels already exist in that form.

It should be noted that there is a new competing proposal [[N3377]] for C2y,
which instead proposes:

```cpp
for outer (/* ...*/) {
    while (/* ... */) break outer;
    while outer (/* ... */) {
        // OK, applies to the enclosing while loop
    }
}
```

In summary, the competing syntax has the technical benefit that
it doesn't require each `label:` to be unique within a function.
This allows the developer to expand function-style macros containing labeled loops
multiple times, and lets them repurpose simple names like `outer` and `inner` within the same function.

We address these technical issues in [[#changes-to-labels]], however,
not with the [[N3377]] syntax.

### Two sets of labels for disambiguation ### {#n3377-label-disambiguation}

Another benefit is that `goto` jump targets and loop names don't share syntax, and this
disambiguates code (with [[N3377]] syntax):
- When a developer sees `label:`, they know that this label is a jump target for `goto`.
- When a developer sees `for name`, they know that this `name`
    is a target for `break` or `continue`, and cannot be jumped to with `goto`.

For C, this is not a negligible concern.
`goto` is slightly more common than `continue;`
in C code on GitHub (source: [[#how-common-is-break-continue-label]]),
but approx. half as common as `break;`.
This means that for any `label:` with the [[N3355]] syntax in C,
there is a decent chance that there are `goto`s nearby.

However, this problem is easy to overstate.
Firstly, this ambiguity *only* exists for labeled loops,
since arbitrary statements cannot be targeted by `break` or `continue`.
For example, `label: free(pointer)` is obviously a `goto` target.

Secondly, we can make an educated guess about the purpose of a label in many situations:

- Labels towards the end of a function are likely targets for prior `goto`s
    which jump to cleanup/error handling code.
- Labels inside of loops are less likely to be `goto` targets because jumping into the middle of
    a is quite surprising, and may be illegal due to crossing initialization
    of a loop variable.
- Labels such as `end:`, `stop:`, `done:`, `success:`, `cleanup:`, `error:`, etc.
    heavily imply that earlier code uses `goto` to get there.
- Labels such as `loop:`, `outer:`, etc.
    heavily imply that code inside the loop uses `break label;` or `continue label;`.

#### Naming conventions as a workaround #### {#n3377-naming-convention-workaround}

Furthermore, disambiguation of `goto` targets and `break`/`continue` targets
is possible through naming conventions for labels.
For example, `break` and `continue` targets can be named `xzy_loop`,
and such names can be avoided for `goto` jump targets.

Virtually every programming community already uses naming conventions for disambiguation.
For example, method names conventionally use `camelCase` in Kotlin,
and class names conventionally use `PascalCase`.
This effectively disambiguates constructor calls from regular function calls for `F()`.

Naming conventions seem like a reasonable solution for disambiguating
`goto` targets from `break` targets.
We don't need to create two distinct label syntaxes to accomplish this.
We can let people choose for themselves whether they want such disambiguation or not,
which is much more in line with C and C++ design philosophy.

### Strong opposition to N3377 ### {#opposition-to-n3377}

We strongly oppose the N3377 syntax for multiple reasons, listed below.

#### Breaking precedent of most prior art #### {#against-n3377-breaking-precedent}

Most languages that supports both labeled loop control
and `goto` statements have a single label syntax.
[[N3377]] breaks this pattern.

<div class=example>
Perl supports `goto LABEL`, `last LABEL`, and `next LABEL`, with shared label syntax:

```perl
goto LINE;
LINE: while (true) {
    last LINE;  # like our proposed break LINE
}
```
</div>

<div class=example>
Go supports `goto Label`, `break Label`, and `continue Label`, with shared label syntax:

```go
goto OuterLoop
OuterLoop: for {
    break OuterLoop
}
```
</div>

<div class=example>
D supports `goto label`, `break label`, and `continue label`, with shared label syntax:

```d
goto outer;
outer: while (true) {
    break outer;
}
```
</div>

The fact that none of these languages require separate syntax
for `goto` targets and `break` targets proves that the syntax proposed by [[N3377]]
is unnecessary, from a technical viewpoint.
C is not so different from D or Go that this argument doesn't apply.

Such separate syntax would also be very surprising to Go, Perl, and D developers coming to C++
because they could reasonably expect `label:` to work for any kind of jump.

To be fair, opposite precedent also exists:
<div class=example>
Ada supports `goto Label` with `<<Label>>`, and
`exit label` with `Label:`:

```ada
goto Target;
<<Target>>
Outer: loop
    exit Outer; -- like our proposed break Outer
end loop Outer;
```
</div>

#### Teachability, Simplicity, Elegance #### {#against-n3377-teachability}

C and C++ have had the `label:` syntax for labeling statements
for multiple decades now.
It is extremely well understood, and has been replicated by other C-esque languages, such as
Java, Rust, JavaScript, Kotlin, and more.
Based on the numbers in [[#how-common-is-break-continue-label]], we can assume that `label:`-like
syntax has been used in over a million files already.

Now, decades after the fact, and a million files later,
we need to invent our own, novel syntax *just* for labeling loops and `switch`es?
No, we don't!
Go, Perl, and D didn't need to either.

The [[N3355]] syntax can be intuitively understood at first glance,
either through intuition from `goto` labels,
or from prior experience with other languages.
On the contrary, given the precedent set by `if constexpr`, the `for outer` syntax
could mislead a user into believing that `outer` is some kind of contextual keyword.
These first experiences matter.

#### Reusable syntax in multi-language systems #### {#against-n3377-multi-language}

C and C++ do not exist in a vacuum.
They are often being used to implement lower-level details of a larger system,
written in another language (e.g. NumPy, which combines Python, C, and C++).

In such a multi-language system,
it is highly beneficial to have common syntax because developers don't have to learn
two entirely different languages, but rather, one and a half.
With [[N3355]], C and C++ could have identical label syntax to JavaScript, Java,
and other languages with which they are paired.
[[N3377]] wastes this opportunity.

#### Instant tooling integration #### {#against-n3377-instant-tooling-integration}

Since the [[N3355]] syntax reuses existing `label:` syntax,
it is immediately compatible with existing tooling, such as syntax highlighters,
auto-formatters, and more.

#### `do` ... `while` #### {#against-n3777-do-while}

<div class=example>
[[N3377]] proposes the following syntax for `do` ... `while` loops:

```cpp
do {
    // ...
    break name;
    // ...
} while name(/* ... */);
```
</div>

This is consistent with `while` loops because the *block-name*
is always placed after the `while` keyword.
However, it also means that `break` and `continue` can apply to a *block-name*
which has not yet appeared in the code.
This is a readability issue; with the exception of `goto` and labels,
function bodies can be understood by reading them from top to bottom.

Note: Of course, there are also entities that can be outside the function body,
like other called (member) functions, types, etc.
However, control flow and use of local entities generally follow a top-to-bottom
structure.

<div class=example>
In larger functions, this can also be incredibly disorienting:

```cpp
while /* outer? */(true) {
    // ...
    // ...
    // ...
    do {
        while (true) {
            // ...
            if (condition)
                break outer; // <<< you are here
            // ...
        }
        // ...
        // ...
        // ...
    } while /* outer? */(true);
}
```

When starting to read this code from the middle
(perhaps after jumping to a specific line in there),
the reader doesn't even know whether they should look further up, or further down when
searching for the loop labeled `outer`.
</div>

To be fair, `do` ... `while` loops are relatively rare, so assuming that the *block-name*
can be found above is usually correct.
However, it is not always correct, and that makes this syntax less ergonomic.

<div class=example>
On the contrary, the [[N3355]] (and our) syntax *never* have `break` apply to a name
which appears later:

```cpp
name: do {
    // ...
    break name;
    // ...    
} while (/* ... */)
```
</div>

The [[N3377]] syntax could be adjusted to place the *block-name* after `do`,
but every way to proceed has downsides:

- Either `break` can refer to a *block-name* which appears arbitrarily far below, or
- the *block-name* is not always placed after `while`, which may be hard to teach and remember, or
- the *block-name* can be placed both after `while` and after `do`, which creates to competing
    styles for the same construct.

On the contrary, [[N3355]] has no such issues.

#### Code pronunciation #### {#against-n3377-pronunciation}

<div class=example>
The [[N3377]] syntax interferes with how code is pronounced, from left to right:

```cpp
// "(loop named outer) While x is greater or equal to zero:" 
outer: while (x >= 0) { /* ... */ }

// "While (loop named outer) x is greater or equal to zero:"
while outer(x >= 0) { /* ... */ }
```
</div>

Putting the loop name between the conjunction `while` and the dependent clause `x >= 0` is not
easily compatible with the English language.
A preceding label is less intrusive and doesn't need to be (mentally) pronounced,
like a leading attribute, line number, paragraph number, etc.

This is not just a stylistic argument; it's an accessibility argument.
C++ developers who rely on screen readers cannot "skip over" or "blend out" the `outer`
like a sighted developer,
and benefit from code that is more naturally pronounceable.


#### Repetition #### {#against-n3377-repetition}

In the event that a user wants to be `break` out of a loop and `goto` it,
in the same function, repetition is needed:

```cpp
goto outer;
// ...
outer: while outer(true) {
    while(true) {
        break outer;
    }
}
```

Since traditional labels are entirely separate from the loop names,
we need to specify the `outer` name twice here.
Some people may consider it a benefit to keep loop names strictly separate from jump targets,
however, we see it as detrimental:

- If the label is the same as the loop name, we repeat ourselves.
- Otherwise, we refer to the same statement using two different names,
    which feels disorienting.
    If we have a good, meaningful label for a loop, such as `main_event_loop:`,
    why shouldn't we also write `while main_event_loop`?

#### Extendability #### {#against-n3377-extendability}

Consider the following (not proposed) construct:

```cpp
label: {
    break label;
}
```

Note: C++ allows you to emulate such `break`s with `goto past_the_block;`,
but see [[#alternative-goto]].

Other mainstream languages already have such a feature:
- That code above is valid Java, JavaScript, and TypeScript.
- When replacing `label` with `'label`, the code is valid Rust.
- Scala has
    <a href="https://www.scala-lang.org/api/current/scala/util/control/Breaks.html">`breakable` blocks</a>
    in which `break()` can be used the same way.

Breaking a *block-statement* is currently *not* proposed, however:
- What if someone wants to propose `break`ing block statements in the future?
    There is no obvious [[N3377]]-like syntax for adding an identifier to a *block-statement*.
    Are we really certain that we will never want to do this, in the next 50 years?
- What if someone wants to add such `break`s as a compiler extension right now?
    With the [[N3377]] syntax, this wouldn't make sense,
    considering that "`goto` labels" cannot be addressed by `break` at all.
- What about new statement that we want to be `break`able?
    Every new statement would need some unique way of adding a name,
    instead of us being able to use `label:` in every case.

On the contrary, the [[N3355]] syntax makes no such problematic commitments,
and is easily compatible with
- existing language extensions like "GCC computed `goto`",
- every new statement in the future, and
- new language extensions, like `break` for block-statements.

#### Blocking contextual keywords #### {#against-n3377-keywords}

Considering that the user is able to add arbitrary identifiers after `while` and `for`,
this makes it impossible to add future contextual keywords in that place without
potentially breaking code:

```cpp
while parallel(/* ... */)
```

If `parallel` was used as a label here, that may be broken by "parallel while loops" in the future.
There is precedent for such changes in C++, in the form if `if constexpr`.
To be fair, `constexpr` is a true keyword, so the addition of `constexpr` after `if`
wouldn't have been blocked by [[N3377]] syntax either (if [[N3377]] was part of C++ at the time).

Nonetheless, it is substantial commitment to block contextual keywords with the [[N3377]] syntax,
and we don't see that commitment as justified. 

#### Labeling loops expanded from macros #### {#against-n3377-macro-loops}

Because [[N3355]] loop labels are prepended, they can also be applied to loops
expanded from macros.
Such macro-expanded loops are relatively common in C.

<div class=example>
The `HASH_ITER` macro from uthash expands to a for loop;
see [[UthashDocs]].

```cpp
#define HASH_ITER(hh,head,el,tmp)                                                              \
for(((el)=(head)), ((*(char**)(&(tmp)))=(char*)((head!=NULL)?(head)->hh.next:NULL));           \
  (el) != NULL; ((el)=(tmp)), ((*(char**)(&(tmp)))=(char*)((tmp!=NULL)?(tmp)->hh.next:NULL)))
```

The [[N3355]] syntax lets the user `break` out of a `HASH_ITER` loop as follows:
```cpp
struct my_struct *current_user, *tmp;

outer: HASH_ITER(hh, users, current_user, tmp) {
    for (/* ... */) {
        if (/* ... */) break outer;
    }
}
```
</div>

The [[N3377]] syntax makes it impossible to apply labels to existing such loop macros.
To add a *block-name*, cooperation from the library author is needed.

Note: This argument is not so important to C++ because such loops would idiomatically be written
as a function template containing a loop;
instead, this argument is targeted towards C developers, who cannot use templates.


## Changes to labels ## {#changes-to-labels}

[[N3377]] points out legitimate issues with reusing the `label:` syntax (see [[#syntax]]).
However, as stated, we strongly oppose the proposed [[N3377]] syntax,
and we propose to make changes to label semantics instead.
These changes keep the syntax the same as [[N3355]].

First and foremost, we permit the same `label:` multiple times within the same function,
see [[#changes-to-labels]].

<div class="example">

```cpp
outer: while (true) {
    inner: while (true) {
        break outer; // breaks enclosing outer while loop
    }
}

outer: while (true) { // OK, reusing label is permitted
    inner: while (true) {
        break outer; // breaks enclosing outer while loop
    }
}

goto outer; // error: ambiguous jump target
```
</div>

Note: This code is well-formed Java and JavaScript.
When using the labels `'outer` and `'inner` instead, this code is also well-formed Rust.

In other words, we are doubling down on the [[N3355]] syntax and changing labels to behave
more like other mainstream languages.


### New labels - `goto` issues ### {#new-labels-goto}

The label changes have some implications for `goto`:
```cpp
x: f();
x: g();
goto x; // error: jump is ambiguous
```

Labeling multiple statements with `x:` would now be permitted.
Even though this is essentially useless considering that `f()` and `g()` are not loops,
it makes the rules easier to teach, and easier to understand;
there are no special rules for loops.

`goto x;` is ill-formed because it is ambiguous which `x:` label it is meant to jump to.
This change doesn't break any existing code because existing code cannot have such ambiguities.


### New labels - what about nesting? ### {#new-labels-nesting}

Another case to consider is the following:

```cpp
l: while (true) {
    l: while (true) {
        break l;
    }
}
```

Note: This code is not valid Java or JavaScript, but is valid Rust when using the label `'l`.

We believe that this code should be well-formed.
Developers may run into this case when nesting pairs of `outer:`/`inner:`
loops in each other "manually",
or when a `l:` labeled loop in a macro is expanded into a surrounding loop that also uses `l:`.

Such cases are the motivation for [[N3377]], and should be addressed.
[[N3355]] does not currently permit such nesting,
and that fact will have to be resolved somehow,
either by significant syntax changes through [[N3377]],
or through relaxation of label rules.

### New labels - what about direct duplicates? ### {#new-labels-duplicates}

A more extreme form of the scenario above is:

```cpp
l: l: l: l: f();
```
We also believe that this code should be well-formed because it's not harmful,
and may be useful in certain, rare situations.

<div class=example>
A somewhat common C idiom is to expand loops from macros;
see also [[#against-n3377-macro-loops]].

```cpp
outer: MY_LOOP_MACRO(/* ... */) {
    break outer;
}
```

If `MY_LOOP_MACRO` already uses an `outer:` label internally,
perhaps because it expands to two nested loops and uses `continue outer;` itself,
then the macro effectively expands to `outer: outer:`.

This forces the user to come up with a new label now, for a seemingly arbitrary reason.
</div>

Permitting this case has the benefit that *no code at all* can become ill-formed through
applying labels.
This rule is simple, teachable, and easy to implement.

### New labels - what about `break label` for loops with more than one label? ### {#new-labels-break-label-multiple}

Another case to consider is this:

```cpp
x: y: while (true) {
    break x;
}
```

Grammatically, `x: y: ...` is a *labeled-statement*,
where the *statement* is another *labeled-statement* `y: ...`,
with a *label* `y` and a *statement* `while ...`.
In other words, `x:` doesn't even apply directly to the loop.

[[N3355]] makes wording changes specifically to address this, and to make this well-formed.
So are we; this code should well-formed if only for the sake of C2y compatibility.


# Impact on existing code # {#impact-on-existing-code}

No existing code becomes ill-formed or has its meaning altered.
This proposal merely permits code which was previously ill-formed,
and relaxes restrictions on the placement of labels.


# Implementation experience # {#implementation-experience}

LLVM implementation W.I.P.




# Proposed wording # {#proposed-wording}

<style>
table, th, td {
    border-color: rgba(0, 0, 0, 0.5);
}

@media (prefers-color-scheme: dark) {
table, th, td {
    border-color: rgba(255, 255, 255, 0.5);
}
}

.indent {
    padding-left: 2em;
}

svg {
    background: none;
    vertical-align: middle;
}

ins {
    background: rgba(136, 255, 93, 0.2);
    color: inherit;
}
ins::not(.ins-block) {
    text-decoration: underlined;
}

.ins-block, .ins-block * {
    text-decoration: none !important;
}
.ins-block {
    background: rgba(136, 255, 93, 0.2) !important;
}

del {
    background: rgba(255, 93, 93, 0.2);
    color: inherit;
    text-decoration: strikethrough;
}
</style>

The wording is relative to [[!N5001]].

Update
<a href="https://eel.is/c++draft/stmt.label">[stmt.label]</a>
paragraph 1 as follows:

<blockquote>
A label can be added to a statement or used anywhere in a *compound-statement*.
<div class="indent">
    *label*:<br>
    <div class="indent">
        *attribute-specifier-seq*<sub>opt</sub> *identifier* `:`<br>
        *attribute-specifier-seq*<sub>opt</sub> `case` *constant-expression* `:`<br>
        *attribute-specifier-seq*<sub>opt</sub> `default` `:`
    </div>
    *labeled-statement*:<br>
    <div class="indent">
        <del>*label*</del><ins>*label-seq*</ins> *statement*
    </div>
    <ins>*label-seq*:</ins><br>
    <div class="indent">
        <ins>*label-seq*<sub>opt</sub> *label*</ins>
    </div>
</div>
The optional *attribute-specifier-seq* appertains to the label.
<del>The only use of a label with an *identifier* is as the target of a `goto`.
No two labels in a function shall have the same identifier.</del>
A label can be used in a `goto` statement before its introduction.
</blockquote>

Note: The grammar change is necessary so that we can apply multiple labels to a single loop,
like `a: b: for (...)`.
Otherwise, it is more difficult to say when a loop is is labeled by a label,
since we need to consider all enclosing *label-statement*s recursively,
but without other intervening statements.

In
<a href="https://eel.is/c++draft/stmt.label">[stmt.label]</a>
insert a new paragraph after paragraph 1:
<blockquote>
<ins>
    Every *label* in the *label-seq* of a *labeled-statement* **S** *labels*
    the *statement* of **S**.
</ins>
</blockquote>

Update
<a href="https://eel.is/c++draft/stmt.label">[stmt.label]</a>
paragraph 3 as follows:
<blockquote>
A *control-flow-limited statement* is a statement **S** for which:
<ul>
    <li>
        a `case` or `default` label appearing within **S**
        shall be associated with a `switch` statement ([stmt.switch]) within **S**, and
    </li>
    <li>
        a label declared in **S** shall only be
        referred to by a statement <del>([stmt.goto])</del> in **S**.
    </li>
</ul>
</blockquote>



---

Update
<a href="https://eel.is/c++draft/stmt.jump.general">[stmt.jump.general]</a>
paragraph 1 as follows:

<blockquote>
Jump statements unconditionally transfer control.
<div class="indent">
    *jump-statement*:
        <div class="indent">
            <ins>`goto` *identifier* `;`</ins><br>
            `break` <ins>*identifier*<sub>opt</sub></ins> `;`<br>
            `continue` <ins>*identifier*<sub>opt</sub></ins> `;`<br>
            `return` *expr-or-braced-init-list*<sub>opt</sub> `;`<br>
            <del>`goto` *identifier* `;`</del><br>
        </div>
</div>
</blockquote>

Note: `goto` is being relocated to the top so that all the jump statements with an *identifier*
are grouped together.
Of these three, `goto` is being listed first because it models the concept of
"jumping somewhere" most literally; every following statement is more sophisticated or even
defined as equivalent to `goto` (in the case of `continue`).

---

Update
<a href="https://eel.is/c++draft/stmt.break">[stmt.break]</a>
paragraph 1 as follows:

<blockquote>
<ins>A *breakable statement* is
an *iteration-statement* ([stmt.iter]) or a `switch` statement ([stmt.switch]).</ins>
A `break` statement shall be enclosed by ([stmt.pre])
<ins>a breakable statement</ins>
<del>an *iteration-statement* ([stmt.iter]) or a `switch` statement ([stmt.switch])</del>.
<ins>If specified, the *identifier* shall label ([stmt.label]) an enclosing breakable statement.</ins> 
The `break` statement causes termination of
<del>the smallest such enclosing statement;</del>
<ul>
    <li>
        <ins>the smallest enclosing breakable statement labeled by the *identifier* if present, otherwise</ins>
    </li>
    <li>
        <ins>the smallest enclosing breakable statement.</ins>
    </li>
</ul>
<del>control</del><ins>Control</ins> passes to the statement following the terminated statement, if any.
<br><br>
<div class="ins-block">
[Example:
<pre>
a: b: while (/* ... */) {
    a: c: for (/* ... */) {
        break;              // OK, terminates enclosing for loop
        break a;            // OK, same
        break b;            // OK, terminates enclosing while loop
        break z;            // error: break does not refer to a breakable statement
    }
    break c;                // error: break does not refer to an enclosing statement
}
break;                      // error: break must be enclosed by a breakable statement
z:;
</pre>&mdash; *end example*]
</div>
</blockquote>

---

Update
<a href="https://eel.is/c++draft/stmt.cont">[stmt.cont]</a>
paragraph 1 as follows:

<blockquote>
A `continue` statement shall be enclosed by ([stmt.pre]) an *iteration-statement* ([stmt.iter]).
<ins>If specified, the *identifier* shall label ([stmt.label]) an enclosing *iteration-statement*.</ins> 
The `continue` statement causes control to pass to the loop-continuation portion
<ins>(that is, to the end of the loop)</ins> of
<del>the smallest such enclosing statement, that is, to the end of the loop.</del>
<ul>
    <li>
        <ins>the smallest enclosing *iteration-statement* labeled by the *identifier* if present, otherwise</ins>
    </li>
    <li>
        <ins>the smallest enclosing *iteration-statement*.</ins>
    </li>
</ul>
More precisely, in each of the statements
<pre>
<ins>label: </ins>while (foo) {
  {
    // ...
  }
contin: ;
}

<ins>label: </ins>do {
  {
    // ...
  }
contin: ;
} while (foo);

<ins>label: </ins>for (;;) {
  {
    // ...
  }
contin: ;
}
</pre>
a `continue` not contained in an
enclosing <del>iteration statement</del><ins>*iteration-statement* or a `continue label`</ins>
is equivalent to `goto contin`.
</blockquote>

---

Update
<a href="https://eel.is/c++draft/stmt.goto">[stmt.goto]</a>
paragraph 1 as follows:

<blockquote>
The `goto` statement unconditionally transfers control to <del>the</del><ins>a</ins> statement
labeled <ins>([stmt.label])</ins> by the <del>identifier</del><ins>*identifier*</ins>.
The <del>identifier</del><ins>*identifier*</ins> shall be
a label located <ins>exactly once</ins> in the current function.
</blockquote>


# Acknowledgements # {#acknowledgements}

I thank Sebastian Wittmeier for providing a list of languages that support both
`goto` and `break`/`last` with the same label syntax.
This has been helpful for writing [[#against-n3377-breaking-precedent]].

I thank the
[Together C & C++](https://discord.gg/tccpp) community for respond to my poll; see [[TCCPP]].

<pre class=biblio>
{
    "MISRA-C++": {
        "authors": ["MISRA Consortium Limited"],
        "title": "MISRA C++:2023",
        "href": "https://misra.org.uk/product/misra-cpp2023/"
    },
    "CppCoreGuidelinesES76": {
        "authors": ["CppCoreGuidelines contributors"],
        "title": "CppCoreGuidelines/ES.76: Avoid goto",
        "href": "https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-goto"
    },
    "GotoConsideredHarmful": {
        "authors": ["Edgar Dijkstra"],
        "title": "Go To Statement Considered Harmful",
        "href": "https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf",
        "date": "1968"
    },
    "isocpp-core": {
        "authors": ["CWG"],
        "title": "Discussion regarding continue vs. goto in constant expressions",
        "href": "https://lists.isocpp.org/core/2023/05/14228.php"
    },
    "std-proposals-2": {
        "authors": ["Filip"],
        "title": "Improving break & continue",
        "href": "https://lists.isocpp.org/std-proposals/2024/11/11585.php"
    },
    "StackOverflow": {
        "authors": ["Faken"],
        "title": "Can I use break to exit multiple nested 'for' loops?",
        "href": "https://stackoverflow.com/q/1257744/5740428",
        "date": "10 Aug 2009"
    },
    "UthashDocs": {
        "authors": ["Troy D. Hanson", "Arthur O'Dwyer"],
        "title": "uthash User Guide: Deletion-safe iteration",
        "href": "https://troydhanson.github.io/uthash/userguide.html#deletesafe"
    },
    "TCCPP": {
        "title": "Poll at Together C & C++ (discord.gg/tccpp)",
        "href": "https://discord.com/channels/331718482485837825/851121440425639956/1318965556128383029"
    },
    "N3355": {
        "authors": ["Alex Celeste"],
        "title": "N3355: Named loops, v3",
        "href": "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3355.htm",
        "date": "2024-09-18"
    },
    "N3377": {
        "authors": ["Erich Keane"],
        "title": "N3377: Named Loops Should Name Their Loops: An Improved Syntax For N3355",
        "href": "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3377.pdf"
    }
}
</pre>
