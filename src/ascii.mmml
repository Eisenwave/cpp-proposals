\def[\cppblock{...}]{\codeblock[cpp]{\put}}
\def[\charset{...}]{\html-code{\html-h-[data-h=str]{[\put]}}}
\def[\exposid{...}]{\i{\html-h-[data-h=id]{\put}}}
\def[\ctype]{\exposid{character-type}}
\def[\stable-ref{...}]{\html-span[class=stable-ref]{[\put]}}
\def[\header{...}]{\code[cpp]{\html-h-[data-h=str]{<\put>}}}
\def[\eelis{...}]{\ref[https://eel.is/c++draft/\put]}

\comment{This solely exists to interfere less with TeX highlighting}
\def[\dollar]{\U{24}}
\def[\percent]{\U{25}}

\comment{
    These macros make our wording very similar to C++ draft TeX,
    making the job of the editors much more convenient.
}
\def[\tcode{...}]{\code[cpp]{\put}}
\def[\grammarterm{...}]{\gterm{\put}}
\def[\itemdecl{...}]{\codeblock[cpp,borders=no]{\put}}
\def[\itemdescr{...}]{\indent{\paragraphs{\put}}}
\def[\expects]{\i{Preconditions}:}
\def[\remarks]{\i{Remarks}:}
\def[\returns]{\i{Returns}:}

\wg21-head[
    title = ASCII character utilities
]{
\dl{
    \dt{Document number:} \dd{\ref[https://wg21.link/D3688R0]{D3688R0}}
    \dt{Date:}            \dd{\tt{2025-05-09}}
    \dt{Audience:}        \dd{LEWG, SG16}
    \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
    \dt{Author:}          \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
    \dt{Co-Authors:}      \dd{Corentin Jabot <\mail{corentin.jabot@gmail.com}>}
    \dt{GitHub Issue:}    \dd{\ref[https://wg21.link/P3688R0/github]}
    \dt{Source:}          \dd{\ref[https://github.com/Eisenwave/cpp-proposals/blob/master/src/ascii.mmml]}
}
\hr
}

\abstract{
The utilities in \header{cctype} or \header{locale}
are locale-specific,
not \tcode{constexpr},
and provide no support for Unicode character types.
We propose lightweight, locale-independent alternatives.
}

\h2[listed=no]{Contents}

\make-contents

\h2{Introduction}

Testing whether a character falls into a specific subset of ASCII characters
or performing some simple transformations are common tasks in text processing.
For example, applications may need to check if identifiers
are comprised of alphanumeric ASCII characters or underscores;
Unicode properties are not relevant to this task,
and usually, neither are locales.

Unfortunately, these common and simple tasks are only supported
through functions in the \header{cctype} and \header{locale} headers, such as:
\cppblock{
// <cctype>
int isalnum(int ch);
int isalpha(int ch);
// ...
int toupper(int ch);

// <locale>
template<class charT> bool isalnum(charT c, const locale& loc); 
}

Especially the \header{cctype} functions are ridden with problems:
\ol{
\item{
    There is no support for Unicode character types
    (\tcode{char8_t}, \tcode{char16_t}, and \tcode{char32_t}).
}
\item{
    These functions are not \tcode{constexpr},
    but performing basic characters tests would be useful at compile time.
}
\item{
    There are distinct function names for \tcode{char} and \tcode{wchar_t}
    such as \tcode{std::isalnum} and \tcode{std::iswalnum},
    making generic programming more difficult.
}
\item{
    If \tcode{char} is signed,
    these functions can easily result in undefined behavior
    because the input must be representable as \tcode{unsigned char} or be \tcode{EOF}.
    If \tcode{char} represents a UTF-8 code unit,
    passing any non-ASCII code unit into these functions has undefined behavior.
}
\item{
    These functions violate the zero-overhead principle
    by also handling an \tcode{EOF} input,
    and in many use cases, \tcode{EOF} will never be passed into these functions anyway.
    The caller can easily deal with \tcode{EOF} themselves.
}
\item{
    The return type of charater tests is \tcode{int},
    where a nonzero return value indicates that a test succeeded.
    This is very unnatural in C++, where \tcode{bool} is more idiomatic.
}
\item{
    Some functions use the currently installed \tcode{"C"} locale,
    which makes their use questionable for high-performance tasks
    because each invocation is typically an opaque call that checks the current locale.
}
}

\strong{We propose lightweight replacement functions which address all these problems.}

\note{
Many of these problems are resolved by the
\tcode{std::locale} overloads in \header{locale},
but their locale dependence makes them unfit for what this proposal aims to achieve.

Testing whether a \tcode{char8_t} (assumed to be a UTF-8 code unit)
is an ASCII digit is obviously a locale-independent task.
}

\h2{Design}

All proposed functions are \tcode{constexpr},
locale-independent,
overloaded (i.e. no separate name for separate input types),
and accept any character type
(\tcode{char}, \tcode{wchar_t}, \tcode{char8_t}, \tcode{char16_t}, and \tcode{char32_t}).
Furthermore, all function names contain \tt{ascii}
to raise awareness for the fact that these functions do not handle Unicode characters.
A user would expect \tcode{is_upper(U'Ä')} to be \tcode{true},
but \tcode{is_ascii_upper(U'Ä')} to be \tcode{false}.

\example{
The counterpart to \tcode{std::isalpha} is declared follows:
\cppblock{
constexpr bool is_ascii_alpha(\exposid{character-type} c) noexcept;
}
}

\tcode{\ctype} means that there exists an overload set where
this placeholder is replaced with each of the character types.
This design is more consistent with \tcode{std::from_chars} and \header{cmath} functions
than say, \tcode{template<class Char>}.
Equivalent functions could also be added to C, if there is interest.
This signature also allows the use with types that are convertible to a specific character type.

\style{
#fun-table {
    margin-left: auto;
    margin-right: auto;
    max-width: 95%;
    table-layout: auto;
}
#fun-table td:not(:last-child),
#fun-table th {
    white-space: nowrap;
    vertical-align: top;
}
#fun-table td:last-child,
#fun-table th:last-child {
    width: 100%;
    text-align: center;
}
}

\h3{List of proposed functions}

Find below a list of proposed functions.
Note that the character set notation \tt{[}...\tt{]} is taken from RegEx.

\table[id=fun-table]{
\tr{
    \th{\header{cctype} counterpart}
    \th{Proposed name}
    \th{Returns (given ASCII \tcode{char c})}
}
\tr{
    \td{\tcode{isdigit}}
    \td{\tcode{is_ascii_digit}}
    \td{\tcode{true} if \tcode{c} is in \charset{0-9}, otherwise \tcode{false}}
}
\tr{
    \td{N/A}
    \td{\tcode{is_ascii_bit}}
    \td{\tcode{c == '0' || c == '1'}}
}
\tr{
    \td{N/A}
    \td{\tcode{is_ascii_octal_digit}}
    \td{\tcode{true} if \tcode{c} is in \charset{0-7}, otherwise \tcode{false}}
}
\tr{
    \td{\tcode{isxdigit}}
    \td{\tcode{is_ascii_hex_digit}}
    \td{\tcode{true} if \tcode{c} is in \charset{0-9A-Fa-f}, otherwise \tcode{false}}
}
\tr{
    \td{\tcode{islower}}
    \td{\tcode{is_ascii_lower}}
    \td{\tcode{true} if \tcode{c} is in \charset{a-z}, otherwise \tcode{false}}
}
\tr{
    \td{\tcode{isupper}}
    \td{\tcode{is_ascii_upper}}
    \td{\tcode{true} if \tcode{c} is in \charset{A-Z}, otherwise \tcode{false}}
}
\tr{
    \td{\tcode{isalpha}}
    \td{\tcode{is_ascii_alpha}}
    \td{\tcode{is_ascii_lower(c) || is_ascii_upper(c)}}
}
\tr{
    \td{\tcode{isalnum}}
    \td{\tcode{is_ascii_alphanumeric}}
    \td{\tcode{is_ascii_alpha(c) || is_asci_digit(c)}}
}
\tr{
    \td{\tcode{ispunct}}
    \td{\tcode{is_ascii_punctuation}}
    \td{\tcode{true} if \tcode{c} is in \charset{!"#\dollar\percent&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~}, otherwise \tcode{false}}
}
\tr{
    \td{\tcode{isgraph}}
    \td{\tcode{is_ascii_graphical}}
    \td{\tcode{is_ascii_alphanumeric(c) || is_ascii_punctuation(c)}}
}
\tr{
    \td{\tcode{isprint}}
    \td{\tcode{is_ascii_printable}}
    \td{\tcode{is_ascii_graphical(c) || c == ' '}}
}
\tr{
    \td{\tcode{isblank}}
    \td{\tcode{is_ascii_horizontal_whitespace}}
    \td{\tcode{c == ' ' || c == '\\t'}}
}
\tr{
    \td{\tcode{isspace}}
    \td{\tcode{is_ascii_whitespace}}
    \td{\tcode{true} if \tcode{c} is in \charset{ \\f\\n\\r\\t\\v}, otherwise \tcode{false}}
}
\tr{
    \td{\tcode{iscntrl}}
    \td{\tcode{is_ascii_control}}
    \td{\tcode{(c >= 0 && c <= 0x1F) || c == '\\N{DELETE}'}}
}
\tr{
    \td{\tcode{tolower}}
    \td{\tcode{ascii_to_lower}}
    \td{the respective lower-case character if \tcode{is_ascii_upper(c)} is \tcode{true}, otherwise \tcode{c}}
}
\tr{
    \td{\tcode{toupper}}
    \td{\tcode{ascii_to_upper}}
    \td{the respective upper-case character if \tcode{is_ascii_lower(c)} is \tcode{true}, otherwise \tcode{c}}
}
\tr{
    \td{N/A}
    \td{\tcode{ascii_case_insensitive_compare}}
    \td{\i{see below}}
}
\tr{
    \td{N/A}
    \td{\tcode{ascii_case_insensitive_equals}}
    \td{\i{see below}}
}
}

\decision{
The proposed names are mostly unabbreviated
to fit the rest of the standard library style.
Shorter names such as \tcode{is_ascii_alphanum} or \tcode{is_ascii_alnum}
could also be used.
}

\decision{
\tcode{isgraph} should perhaps have no new version.
It is of questionable use,
and both the old and new name aren't obvious.
In the default \tcode{"C"} locale,
\tcode{isgraph} is simply \tcode{isprint} without \tcode{' '}.

Similarly, \tcode{isblank} should perhaps have no new version either.
This proposal simply has a new version for every \header{cctype} function;
if need be, they are easy to remove.
}

\h3[id=base-parameter]{\tcode{base} parameter in \tcode{is_ascii_digit}}

Similar to \tcode{std::to_chars},
\tcode{std::is_ascii_digit} can also take a \tcode{base} parameter:

\cppblock{
constexpr bool is_ascii_digit(\ctype c, int base = 10);
}

If \tcode{base} \c{le} \tcode{10},
the range of valid ASCII digit character is simply limited.
For greater \tcode{base}, a subset of alphabetic characters is also accepted,
starting with \tcode{'a'} or \tcode{'A'}.
Such a function is useful when parsing numbers with a base of choice,
which is what \tcode{std::to_chars} does, for example.

\h3[id=binary-and-octal-is-digit]{\tcode{is_ascii_bit} and \tcode{is_ascii_octal_digit}}

C++ and various other programming languages support binary and octal literals,
so it seems like an arbitrary choice to only have dedicated overloads for (hexa)decimal digits.
\tcode{is_ascii_bit} may be especially useful,
such as when dealing with bit-strings like one of the \tcode{std::bitset} constructors.

In conclusion, we may as well have functions for bases 2, 8, 10, and 16;
they're not doing much harm, they're trivial to implement,
and some users may find them useful.

\decision{
None of the authors feel strongly about this,
so if LEWG insists,
we could remove \tcode{is_ascii_bit} and \tcode{is_ascii_octal_digit},
and even remove \tcode{is_ascii_hex_digit},
leaving only the multi-base \tcode{is_ascii_digit}.
}

\h3{Case-insensitive comparison functions}

As shown in the table above,
we also propose the case-insensitive comparison functions.

\cppblock{
constexpr strong_ordering ascii_case_insensitive_compare(
    \ctype a,
    \ctype b
) {
    return ascii_to_upper(a) <=> ascii_to_upper(b);
}

constexpr strong_ordering ascii_case_insensitive_equals(
    \ctype a,
    \ctype b
) {
    return ascii_to_upper(a) == ascii_to_upper(b);
}
}

\decision{
It may also be useful to define function objects in the style of \tcode{std::less}
to enable interoperability with algorithms.
In general, passing these characters tests into algorithms is desirable,
so perhaps all proposed functions should be implemented as function objects
so that the user could write:
\cppblock{
std::string_view str = "abc123";
// This does not work if is_ascii_digit is an overloaded function or function template.
auto it = std::ranges::find(str, is_ascii_digit);
}

However, defining function objects for this purpose may be obsoleted by
\ref[P3312R1] Overload Set Types.
}

\h3[id=encoding]{What to do for ASCII-incompatible \tcode{char} and \tcode{wchar_t}}

Not every ordinary and wide character encoding is ASCII-compatible,
such as EBCDIC, Shift-JIS, and (defunct) ISO-646,
i.e. code units \c{le} \tcode{0x7f} do not represent the same characters as ASCII.
So, what should \tcode{is_ascii_foo(char(/* ... */))} do?
We have three options, discussed below.

\decision{
The authors of this paper disagree on the best approach.
Consensus on one of these three options is needed.
}

\h4{Conditionally supported \tcode{char} overloads}

We could mandate that the ordinary literal encoding is an ASCII superset
for the \tcode{char} overload to exist.
This would force a cast (to \tcode{char8_t}) to use the functions on EBCDIC platforms.
It is not clear how implementations would treat Shift-JIS;
GCC assumes \tcode{'\\\\' == '¥'} to be \tcode{true},
so this option may not be enough to alleviate
the awkwardness of \tcode{is_ascii_punctuation('¥')}.

\h4{Transcode \tcode{char} to ASCII}

We could transcode to ASCII and produce an answer for the result of that transcoding.
This would be a greater burden for implementations,
especially on EBCDIC platforms.
The benefit is that \tcode{is_ascii_alpha('a')} is always \tcode{true},
although \tcode{is_ascii_alpha(char(0x61))} may not be.

It probably does not solve the \tcode{is_ascii_punctuation('¥')} case,
as implementers may keep transcoding \tcode{'¥'} and \tcode{'\\\\'} in the same way.
It would also give incorrect answers for stateful encodings.
There are EBCDIC control characters that do not have an ASCII equivalent,
so if we were to do conversions, we would have to decide what,
for example, \tcode{is_ascii_control('\\u008B')} should produce.

\note{
If we want to perform ASCII tests on \tcode{char c} that is not ASCII-encoded,
we can still do so via \tcode{is_ascii_foo(char8_t(c))} with this option.
}

\h4{Treat the input as ASCII, regardless of the literal encoding (proposed)}

The most simple option is to ignore literal encoding entirely,
and assume that \tcode{char} inputs are ASCII-encoded.
The greatest downside is that depending on encoding,
\tcode{is_ascii_digit('0')} may be \tcode{false},
which may be surprising to the user.

It is important to note that the are use cases for this behavior on EBCDIC platforms.
A lot of protocols (HTTP, POP) and file formats (JSON, XML) are ASCII/UTF-8-based
and need to be supported on EBCDIC systems,
making these functions universally useful,
especially as \header{cctype} functions cannot easily be used to deal with ASCII on these platforms.

Ultimately, do we want functions to deal with ASCII or the literal encoding?
If we want them to be a general way to query the ordinary literal encoding,
\tcode{is_ascii} is a terrible name,
and finding a more general name would prove difficult.

\note{
If we choose this option,
we can still provide the same transcoding functionality as the previous option
by offering a (literal-encoded) \tcode{char} \c{rightarrow} (code point) \tcode{char32_t}
function.
Such an (exposition only) function is currently used in the wording:
\tcode{\exposid{TO-CHAR32}(c)}.
}

\h3{What if the input is a non-ASCII code unit?}

It is possible (and expected) that the user calls say, \tcode{is_ascii_digit(U'ö')}.
For the sake of convenience, all proposed functions should handle such inputs by
\ul{
    \item{returning \tcode{false} in the case of all testing functions, and}
    \item{applying an identity transformation in transformation/case-insensitive comparison functions.}
}

\example{
With these semantics, the user can safely write:
\cppblock{
std::u8string_view str = u8"öab 123";
// it is an iterator to '1'
auto it = std::ranges::find(str, [](char8_t c) { return std::is_ascii_digit(c); });
}
}
Making ASCII inputs a precondition
would make these functions just as unsafe and commonly misused as the \header{cctype} functions.
Throwing on non-ASCII inputs would make them much less convenient to use in algorithms.

The proposed behavior also works very well with any ASCII-compatible encoding, such as UTF-8.
Surrogate code units in UTF-8 are all greater than \tcode{0x7F},
so none of the tests have false positives,
and none of the transformations would affect non-ASCII code units.

\h3{ASCII case-insensitive views and algorithms}

Ignoring ASCII case in algorithms is a fairly common problem.

\example{
HTML tag names are case-insensitive and comprised of ASCII characters,
like \code[html]{<div>}, \code[html]{<DIV>} etc.
To identify a \code[html]{<div>} element, it would be nice if the user could write:
\cppblock{
std::ranges::equal(tag_name | std::views::ascii_lower, "div");
// or
std::ranges::ascii_case_insensitive_equal(tag_name, "div");
// or
tag_name.ascii_case_insensitive_equals("div");
}
}

Therefore, it may be useful to provide views such as \tcode{std::views::ascii_lower}
and even algorithms like \tcode{std::ranges::equal_ascii_case_insensitive}.
These are not currently not included
because there is no consensus among the authors whether to include them.

\decision{
If LEWG is interested,
such views and/or algorithms could be included in a subsequent revision.
}

\h3[id=why-just-ascii]{Why just ASCII?}

It may be tempting to generalize the proposed utilities beyond ASCII, e.g. to UTF-8.
However, this is not proposed for multiple reasons:
\ul{
\item{
    You cannot pass \tcode{char8_t} into a UTF-8 \tcode{is_upper} function
    and expect meaningful results.
    In general, operations on variable-length encodings require sequences of code units.
    The interface we propose \em{only} makes sense for ASCII.
}
\item{
    Unicode utilities are tremendously more complex than ASCII utilities.
    Some Unicode case conversions even require multi-code-point changes.
}
}


\h2{Implementation experience}

An early version of most proposed functions can be found at
\ref[CompilerExplorer].
A naive implementation of all utilities is quite trivial, often a one-liner.

A more advanced implementation of some functions can be found in \ref[µlight].
Character tests can be optimized using 128-bit or 256-bit bitsets.

\h2{Wording}

\important{
The following wording assumes that in
\ref[#encoding],
the second option is chosen.
That is, \tcode{char} is transcoded to \tcode{char32_t} prior to character tests.

If the last option is chosen instead (simply assuming \tcode{char} is ASCII),
\tcode{\exposid{TO-CHAR32}(c)}
can be replaced with \tcode{static_cast<char32_t>(c)},
and \tcode{\exposid{CHAR-ENCODE}<T>(x)}
can be replaced with \tcode{static_cast<T>(x)}.
}

The wording changes are relative to \ref[N5008].

In subclause \eelis{version.syn},
update the synopsis as follows:

\diff{\codeblock[cpp,borders=no]{
\serif{\html{[...]}}
#define __cpp_lib_as_const                          201510L // freestanding, also in <utility>
\ins{#define __cpp_lib_ascii                             20XXXXL // freestanding, also in <ascii>}
#define __cpp_lib_associative_heterogeneous_erasure 202110L // also in \serif{[...]}
\serif{\html{[...]}}
}}

In Clause \eelis{text},
append a new subclause:

\style{
ins-block .para::before {
    display: none;
}

.stable-ref {
    float: right;
}
}

\insblock{
\h2[listed=no]{ASCII utilities \stable-ref{ascii}}

Subclause [ascii] describes components for dealing with characters that are encoded using ASCII
or encodings that are ASCII-compatible, such as UTF-8.

Let \tcode{\exposid{TO-CHAR32}(c)} be defined as follows:
\ul{
    \item{
        If \tcode{c} is of type
        \tcode{char8_t}, \tcode{char16_t}, or \tcode{char32_t},
        or if the literal encoding (\eelis{lex.charset})
        for character literals of the type of \tcode{c}
        is a Unicode character encoding,
        \tcode{\exposid{TO-CHAR32}(c)} is \tcode{static_cast<char32_t>(c)}.
    }
    \item{
        Otherwise, if there exists a character \i{b} in the basic character set
        which equals \tcode{c}
        when encoded using a character literal (\eelis{lex.ccon})
        of the type of \tcode{c},
        \tcode{\exposid{TO-CHAR32}(c)}
        is a UTF-32 character literal which encodes \i{b}.
        \br
        \wg21-example{
            \tcode{\exposid{TO-CHAR32}('x')} is \tcode{U'x'},
            no matter what the ordinary character literal encoding is.
        }
    }
    \item{
        Otherwise, \tcode{\exposid{TO-CHAR32}(c)}
        is a prvalue of type \tcode{char32_t} whose value is implementation-defined.
    }
}

\h3[listed=no]{Header \header{ascii} synopsis \stable-ref{ascii.syn}}

When a function is specified with a type placeholder of
\tcode{\ctype},
the implementation provides overloads for all cv-unqualified 
character types (\eelis{basic.fundamental})
in lieu of \tcode{\ctype}.

\codeblock[cpp,borders=no]{
// \serif{all freestanding}
namespace std {
  // \serif{[ascii.chars.test], ASCII character testing}
  constexpr bool is_ascii_digit(\ctype c, int base = 10);
  constexpr bool is_ascii_bit(\ctype c) noexcept;
  constexpr bool is_ascii_octal_digit(\ctype c) noexcept;
  constexpr bool is_ascii_hex_digit(\ctype c) noexcept;

  constexpr bool is_ascii_lower(\ctype c) noexcept;
  constexpr bool is_ascii_upper(\ctype c) noexcept;
  constexpr bool is_ascii_alpha(\ctype c) noexcept;
  constexpr bool is_ascii_alphanumeric(\ctype c) noexcept;

  constexpr bool is_ascii_punctuation(\ctype c) noexcept;
  constexpr bool is_ascii_graphical(\ctype c) noexcept;
  constexpr bool is_ascii_printable(\ctype c) noexcept;

  constexpr bool is_ascii_horizontal_whitespace(\ctype c) noexcept;
  constexpr bool is_ascii_whitespace(\ctype c) noexcept;

  constexpr bool is_ascii_control(\ctype c) noexcept;

  // \serif{[ascii.chars.transform], ASCII character transformation}
  constexpr \ctype ascii_to_lower(\ctype c) noexcept;
  constexpr \ctype ascii_to_upper(\ctype c) noexcept;

  // \serif{[ascii.chars.case.compare], ASCII case-insensitive character comparison}
  constexpr \ctype ascii_case_insensitive_compare(\ctype a
                                                          \ctype b) noexcept;
  constexpr bool ascii_case_insensitive_equals(\ctype a
                                               \ctype b) noexcept;
}
}

\h3[listed=no]{ASCII character testing \stable-ref{ascii.chars.test}}

\itemdecl{
constexpr bool is_ascii_digit(\ctype c, int base = 10);
}
\itemdescr{
\expects
\tcode{base} has a value between 2 and 36 (inclusive).

\p{
\returns
\codeblock[cpp,borders=no]{\comment   (\exposid{TO-CHAR32}(c) >= U'0' && \exposid{TO-CHAR32}(c) < U'0' + min(base, 10))
|| (\exposid{TO-CHAR32}(c) >= U'a' && \exposid{TO-CHAR32}(c) < U'a' + max(base - 10, 0))
|| (\exposid{TO-CHAR32}(c) >= U'A' && \exposid{TO-CHAR32}(c) < U'A' + max(base - 10, 0))
}
}

\remarks
A function call expression that violates the precondition
in the \i{Preconditions}: element
is not a core constant expression.
}

\itemdecl{
constexpr bool is_ascii_bit(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_digit(c, 2)}.
}

\itemdecl{
constexpr bool is_ascii_octal_digit(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_digit(c, 8)}.
}

\itemdecl{
constexpr bool is_ascii_hex_digit(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_digit(c, 16)}.
}

\itemdecl{
constexpr bool is_ascii_lower(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{\exposid{TO-CHAR32}(c) >= U'a' && \exposid{TO-CHAR32}(c) <= U'z'}.
}

\itemdecl{
constexpr bool is_ascii_upper(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{\exposid{TO-CHAR32}(c) >= U'A' && \exposid{TO-CHAR32}(c) <= U'Z'}.
}

\itemdecl{
constexpr bool is_ascii_alpha(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_lower(c) || is_ascii_upper(c)}.
}

\itemdecl{
constexpr bool is_ascii_alphanumeric(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_alpha(c) || is_ascii_digit(c)}.
}

\itemdecl{
constexpr bool is_ascii_punctuation(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{u32string_view(U"!\\"#\U{24}\U{25}&'()*+,-./:;<=>?@[\\\\]^_`{|}~").contains(\exposid{TO-CHAR32}(c))}.
}

\itemdecl{
constexpr bool is_ascii_graphical(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_alphanumeric(c) || is_ascii_punctuation(c)}.
}

\itemdecl{
constexpr bool is_ascii_printable(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_graphical(c) || \exposid{TO-CHAR32}(c) == U' '}.
}

\itemdecl{
constexpr bool is_ascii_horizontal_whitespace(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{\exposid{TO-CHAR32}(c) == U' ' || \exposid{TO-CHAR32}(c) == U'\\t'}.
}

\itemdecl{
constexpr bool is_ascii_whitespace(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{u32string_view(U" \\f\\n\\r\\t\\v").contains(\exposid{TO-CHAR32}(c))}.
}

\itemdecl{
constexpr bool is_ascii_control(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{\exposid{TO-CHAR32}(c) <= 0x1F || \exposid{TO-CHAR32}(c) == U'\\N{DELETE}'}.
}

\h3[listed=no]{ASCII character transformation \stable-ref{ascii.chars.transform}}

Let \tcode{x} be an expression of integer type
and let \tcode{T} be a character type (\eelis{basic.fundamental}).
Let \tcode{\exposid{CHAR-ENCODE}<T>(x)} be a
is a \grammarterm{character-literal} of type \tcode{T} containing a single
\grammarterm{universal-character-name} which encodes the value of \tcode{x} interpreted as a Unicode code point.
\br\wg21-example{
\tcode{\exposid{CHAR-ENCODE}<char>(0x10 * 2)} is \tcode{'\\u0020'}.
\tcode{\exposid{CHAR-ENCODE}<char32_t>(x)} is equivalent to \tcode{static_cast<char32_t>(x)}
for \tcode{x} \c{le} \tcode{0x10FFFF}.
}

\itemdecl{
constexpr \ctype to_ascii_lower(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_upper(c) ? \exposid{CHAR-ENCODE}<\ctype>(\exposid{TO-CHAR32}(c) - U'A' + U'a') : c}.
}

\itemdecl{
constexpr \ctype to_ascii_upper(\ctype c) noexcept;
}
\itemdescr{
\returns
\tcode{is_ascii_lower(c) ? \exposid{CHAR-ENCODE}<\ctype>(\exposid{TO-CHAR32}(c) - U'a' + U'A') : c}.
}

\h3[listed=no]{ASCII case-insensitive character comparison \stable-ref{ascii.chars.case.compare}}

\itemdecl{
constexpr std::strong_ordering ascii_case_insensitive_compare(\ctype a,
                                                              \ctype b) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_to_upper(a) <=> ascii_to_upper(b)}.
}

\itemdecl{
constexpr bool ascii_case_insensitive_equals(\ctype a,
                                             \ctype b) noexcept;
}
\itemdescr{
\returns
\tcode{ascii_to_upper(a) == ascii_to_upper(b)}.
}

}


\h2{References}

\bib[
    id = N5008,
    title = Working Draft\, Programming Languages — C++,
    date = 2025-03-15,
    author = Thomas Köppe,
    link = https://wg21.link/n5008,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf
]
\bib[
    id = P3312R1,
    title = Overload Set Types,
    date = 2025-04-16,
    author = Bengt Gustafsson,
    link = https://wg21.link/p3312r1,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3312r1.pdf
]
\bib[
    id = CompilerExplorer,
    title = Partial implementation of character utilities,
    author = Corentin Jabot,
    link = https://godbolt.org/z/qbajdhfWE
]
\bib[
    id = µlight,
    title = ascii_chars.hpp utilities in µlight,
    author = Jan Schultke,
    link = https://github.com/Eisenwave/ulight/blob/main/include/ulight/impl/ascii_chars.hpp
]

\make-bib
