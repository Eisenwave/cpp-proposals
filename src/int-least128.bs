<pre class='metadata'>
Title: <code>std::int_least128_t</code>
Shortname: NPxxxx
Revision: 0
Status: NP
Date: 2024-02-11
Group: WG21
Audience: LEWGI, LWG
Editor: Jan Schultke, janschultke@gmail.com
ED: https://eisenwave.github.io/cpp-proposals/int-least128.html
!Source: [eisenwave/cpp-proposals](https://github.com/Eisenwave/cpp-proposals/blob/master/src/int-least128.bs)
Markup Shorthands: markdown on
Abstract: This proposal standardizes mandatory 128-bit integers types with strong library support.
</pre>


# Introduction # {#introduction}

128-bit integers have numerous practical uses, and all major implementations
(MSVC, GCC, LLVM) provide 128-bit integers already.
Among C++ users, there has been great interest in standardizing integers beyond 64 bits for a long time.
With the new wording in the C23 standard for `intmax_t` (see [[#c-compatibility]]),
one of the last obstacles has been removed.

The goal of this paper is to obtain a mandatory &ge; 128-bit integer type with no core language changes
and strong support from the C++ standard library.
To accomplish this, the mandatory aliases `std::int_least128_t` and `std::uint_least128_t`
are proposed.
Note that any non-malicious implementation would be required to define `std::uint128_t` if that
is possible, so standardizing the minimum-width types is standardizing exact-width types by proxy.

While the definition of these aliases is trivial, mandating them also implies
library support from `<format>`, `<bit>`, `<cmath>`, `<limits>`, and other facilities.
After extensive investigation, it was determined that the [[#impact-on-the-standard]]
and [[#implementation-impact]] is relatively low.

## Lifting library restrictions ## {#lifting-library-restrictions}

Furthermore, the standard library contains a large amount of artificial hurdles
which make it impossible to provide library support for extended integers.
The current standard already permits the implementation to provide additional
extended (fundamental) integer types in addition to the standard integers (`int`, `long`, etc.).
However, even if there exists an extended 128-bit integer,
`std::to_string(std::int128_t)` cannot exist,
`std::bitset` cannot be constructed from it (without truncating to `unsigned long long`),
`std::abs(std::int128_t)` cannot exist,
among other issues.

It would not be legal for an implementation to provide such additional overloads because it would
change the meaning of well-formed programs.
<div class=example>
The following code is a compliant C++23 translation unit.
Assuming that the implementation provides `std::uint128_t` (which is permitted),
the code is well-formed.

```cpp
#include <string>

template <typename T>
concept stringable = requires (T t) { std::to_string(t); };

static_assert(not stringable<std::uint128_t>);
```
`std::uint128_t` is not `stringable` because the call to `std::to_string` would be ambiguous.
Defining an additional `std::to_string` overload would make the assertion fail.
</div>

# Motivation and scope # {#motivation-and-scope}

There are two essential reasons for standardizing a 128-bit integer type:

1. 128-bit integers are extremely useful in a variety of domains.

2. 128-bit integers are already implemented in multiple compilers, and quasi-mandated by the C23
    standard through the `_BitInt(128)` and `unsigned _BitInt(128)` types.
    That is, if the implementation defines `BITINT_MAXWIDTH >= 128`.
    See [[#existing-128-bit-integers]] for more.

## Use cases ## {#use-cases}

A GitHub code search for
<a href="/int128|int_128/ language:c++">`/int128|int_128/ language:c++`</a>
yields 150K files,
and a language-agnostic search for
<a href="https://github.com/search?q=%2Fint128%7Cint_128%2F&type=code">`/int128|int_128/`</a>
yields more than a million.

While it is impossible to discuss every one of these,
I will introduce a few use cases of 128-bit integers.

### Cryptography ### {#cryptography}

128-bit integers are commonly used in many cryptographic algorithms:

- Most notably, AES-128 uses a 128-bit key size.
    AES variants with wider key sizes still use a block size of 128 bits.
- Various other block ciphers such as Twofish and Serpent also have key and/or block sizes of 128 bits.
- MD5 hashes produce 128-bit output.
- SHA-2 and SHA-3 produce outputs beyond 128-bit, but outputs can be truncated to 128-bit,
    or represented as a pair/array of 128-bit integers.

### Random number generation ### {#random-number-generation}

Some random number generators produce 128-bit numbers.

For example, the
<a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">CSRPNG</a>
(cryptographically secure pseudo-random number generator)
[Fortuna](https://en.wikipedia.org/wiki/Fortuna_(PRNG))
uses a block cipher to produce random numbers.
When a 128-bit block cipher is used, the output is naturally 128-bit as well.
Fortuna is used in the implementation of `/dev/random` in FreeBSD 11, and in AppleOSes since 2020.

Some PRNGs use a 128-bit state, such as [xorshift128](https://en.wikipedia.org/wiki/Xorshift).
<div class=example>
The following code is based on [[Marsaglia]], with some changes.

```cpp
std::uint32_t xor128(std::uint32_t x[4]) {
    std::uint32_t t = x[3];
    t ^= t << 11;
    t ^= t >> 8;

    x[3] = x[2]; x[2] = x[1]; x[1] = x[0];

    x[0] ^= t ^ (x[0] >> 19);
    return x[0];
}
```

This can be expressed more elegantly using 128-bit integers:
```cpp
std::uint32_t xor128(std::uint128_t& x) {
    std::uint32_t t = x >> 96;
    t ^= t << 11;
    t ^= t >> 8;

    x = (x << 32) | (t ^ (std::uint32_t(x) ^ (std::uint32_t(x) >> 19)));
    return x;
}
```
</div>

Generally speaking, there is a large amount of code that effectively performs
128-bit operations, but operates on sequences of 32-bit or 64-bit integers.
In the above example, it is not immediately obvious that the `x[3] = x[2]; ...` line
is effectively performing a 32-bit shift, whereas `x << 32` is self-documenting.


### Widening operations ### {#widening-operations}

128-bit arithmetic can produce optimal code for mixed 64/128-bit operations,
for which there is already widespread hardware support.
For example, this hardware support includes:

- The x86_64 `mul` (unsigned multiply) instruction stores the result of a 64-to-128-bit multiplication
    in the register pair `rdx:rax`.
- The x86_64 `div` (unsigned divide) instruction stores quotient and remainder of a 128-to-64-bit division
    in `rax` and `rdx` respectively.
- The RISC-V `clmul` and `clmulh` instructions to compute the low and high part of a
    carry-less multiplication.
    In fact, x86, ARM, and RISC-V all provide a way to compute a
    [carry-less 128-bit product](https://en.wikipedia.org/wiki/Carry-less_product). 

Some operating systems also provide 64/128-bit operations.
For example, the Windows API provides a `Multiply128` function.

A more general solution was proposed by [[P3018R0]], which supports widening multiplication through a
`std::mul_wide` function, which yields the low and high part of the multiplication as a pair
of integers.
Such utilities would be useful in generic code where integers of any width can be used,
but it's obviously more ergonomic to cast operands to `std::int128_t` prior to an
operation.


### Multi-precision operations ### {#multi-precision-operations}

For various applications (cryptography, numerics, etc.) arithmetic with large widths is required.
For example, the RSA (Rivest–Shamir–Adleman) cryptosystem typically uses key sizes of 2048 or 4096.
"Scripting languages" also commonly use an infinite-precision integer type.
For example, the `int` type in Python has no size limit.

Multi-precision operations are implemented through multiple widening operations (see above).
For example, to implement N-bit multiplication,
the number can be split into a sequence of 64-bit "digits",
and long multiplication is performed.
Since this involves a carry between digits, a 64-to-128-bit widening operation is required.


### Fixed-point operations ### {#fixed-point-operations}

While 64-bit integers are sufficient for many calculations, the amount of available bits
is reduced when the 64 bits are divided into an integral and fractional part.
This may cause issues in [[#financial-systems]].

Furthermore, fixed-point arithmetic with a double-wide operand can emulate integer division,
which is a relatively expensive operation, even with hardware support.

<div class=example>
128-bit integers allow us to implement a division by three without integer division:
```cpp
std::uint64_t div3(std::uint64_t x) {
    // 1 / 3 as a Q63.65 fixed-point number:
    constexpr std::uint_fast128_t reciprocal_3 = 0xAAAA'AAAA'AAAA'AAAB;
    return (x * reciprocal_3) >> 65; // equivalent to return x / 3;
}
```
</div>

While modern compilers perform this
[strength reduction optimization](https://en.wikipedia.org/wiki/Strength_reduction)
for constant divisors already, they don't perform it for frequently reused non-constant divisors.

For such divisors, it can make sense to pre-compute the reciprocal and shift constants
and use them many times for faster division.
Among other libraries, [[libdivide]] uses this technique
(using a pair of 64-bit integers, which effectively forms a 128-bit integer).


### High-precision time calculations ### {#high-precision-clocks}

64-bit integers are somewhat insufficient for high-precision clocks, if large time spans should
also be covered.
When counting nanoseconds, a maximum value of 2<sup>63</sup>-1 can only represent approximately
9 billion seconds, or 7020 years.
This is enough to keep time for the forseeable future, but is insufficient
for representing historical data long in the past.

This makes 64-bit integers insufficient for some time calculations, where 128-bit integers
would suffice.
Alternatively, 64-bit floating-point numbers can provide a reasonable trade-off
between resolution and range.

`timespec` is effectively a 128-bit type in POSIX (`std::timespec` in C++), since both the
seconds and nanoseconds part of the class are 64-bit integers
(assuming that `std::time_t` is 64-bit).

### Floating-point operations ### {#floating-point-operations}

The implementation of IEEE 754/IEC-559 floating-point operations often involves examining the
bit-representation of the floating-point number through an unsigned integer.

The C++ standard provides `std::float128_t`, but no matching 128-bit integer type,
which makes this more difficult.

<div class="example">
Using 128-bit integers, `std::signbit` can be implemented as follows:

```cpp
bool signbit(float128_t x) {
    return bit_cast<uint128_t>(x) >> 127;
}
```
</div>

### Float-to-string/String-to-float conversion ### {#float-string-conversion}

The [[Dragonbox]] binary-to-decimal conversion algorithm requires an integer type
that is twice the width of the converted floating-point number.
To convert a floating-point number in
[binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)
format, a 128-bit integer type is used.

Similarly, [[fast_float]] uses 128-bit numbers as part of decimal-to-binary conversions.
This library provides an efficient `from_chars` implementation.

### Financial systems ### {#financial-systems}

128-bit integers can be used to represent huge monetary values with high accuracy.
When representing cents of a dollar as a 64-bit integer,
a monetary value of up to 184.5 quadrillion dollars can be represented.
However, this value shrinks dramatically when using smaller fractions.

Since 2005, stock markets are legally required to accept
price increments of $0.0001 when the price of a stock is &le; $1 (see [[SEC]]).
At this precision, 1.84 quadrillion dollars can be represented.
Using a uniform precision of ten thousandths would prove problematic when
applied to other currencies such as Yen, which forces the complexity of variable precision
on the developer.

Even more extremely, the smallest fraction of a Bitcoin is a Satoshi, which is a
hundred millionth of a Bitcoin.
2<sup>63</sup> Satoshis equal approximately 92 billion BTC.
In 2009, a Bitcoin was worth less than a penny, so a monetary value of only
920 million USD could be represented in Satoshis.

In conclusion, simply storing the smallest relevant fraction as a 64-bit integer is
often insufficient, especially when this fraction is very small and exponential
price changes are involved.
Rounding is not always an acceptable solution in financial applications.

[[NVIDIA]] mentions fixed-point accounting calculations as a possible use case of the
`__int128` type, which is a preview feature of NVIDIA CUDA 11.5.

[[TigerBeetle]] discusses why 64-bit integers have been retired in favor of 128-bit
integers to store financial amounts and balances in the TigerBeetle financial
accounting database.
The aforementioned sub-penny requirement is part of the motivation.

### Database systems ### {#database-systems}

A 128-bit integer can be used to represent a
<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>
(Universally Unique Identifier).
While 64-bit integers are often sufficient as a unique identifier, it is quite likely that two
identical identifiers are chosen by a random number generator over a long period of time,
especially considering the
[Birthday Problem](https://en.wikipedia.org/wiki/Birthday_problem).
Therefore, at least 128 bits are typically used for such applications.

<div class=example>
The following code generates a UUIDv4, represented as an unsigned 128-bit integer.
<pre>
std::uint128_t random_uuid_v4() {
    return std::experimental::randint&lt;std::uint128_t&gt;(0, -1)
         & 0x<c- mh="">ffff</c->'<c- mh="">ffff</c->'<c- mh="">ffff</c->'<c- mh="">003f</c->'<c- mh="">ff0f</c->'<c- mh="">ffff</c->'<c- mh="">ffff</c->'<c- mh="">ffff</c->  // clear version and variant
         | 0x<c- mh="">0000</c->'<c- mh="">0000</c->'<c- mh="">0000</c->'<c- mh="">0080</c->'<c- mh="">0040</c->'<c- mh="">0000</c->'<c- mh="">0000</c->'<c- mh="">0000</c->; // set to version 4 and IETF variant
}
</pre>
</div>

### Networking ### {#networking}

IPv6 addresses can be represented as a 128-bit integer.
This may be a convenient representation because bitwise operations for masking and accessing
individual bits or bit groups may be used.
Implementing these is much easier using a 128-bit integers compared to multi-precision operations
using two 64-bit integers.

<div class=example>
An IPv6 address in link-local address format can be identified as follows:
<pre>
std::uint128_t ipv6 = /* ... */;
constexpr auto mask10 = 0x3ff;
if ((ipv6 & mask10) != 0b1111111010) /* wrong prefix */;

constexpr auto mask54 = (std::uint64_t(1) &lt;&lt; 54) - 1;
if ((ipv6 >> 10 & mask54) != 0) /* expected 54 zeros */;

constexpr auto mask64 = std::uint64_t(-1);
interface_identifier = (data &gt;&gt; 64) & mask64;
</pre>
</div>

## Utilizing hardware support ## {#utilizing-hardware-support}

### Future-proofing for direct 128-bit support ### {#future-proofing}

Hardware support for 64/128-bit mixed operations is already common
in x86_64 and ARM.
It is also conceivable that hardware support for 128-bit integer arithmetic will be expanded
in the forseeable future.
The RISC-V instruction set architecture has a 128-bit variant named RV128I,
described in [[RISC-V]], although no implementation of it exists yet.

When hardware support for 128-bit operations is available, but the source code emulates these
in software, the burden of fusing multiple 64-bit operations into a single 128-bit operation
is put on the optimizer.

For example, multiple 64-bit multiplications may be fused into a single 64-to-128-bit
multiplication.
x86_64 already provides hardware support in this case (see [[#widening-operations]]), however,
the language provides no way of expressing such an operation through integer types.

### Support through 128-bit floating-point ### {#support-through-128-bit-floating-point}

On hardware which provides native support for `std::float128_t`
(see [[Wikipedia]] for a list), integer division up to 113
bits can be implemented in terms of floating-point division, and this is possibly the fastest routine.
For such instruction selection, the 113-bit division must be recognized by the compiler.
It is very unlikely that the hundreds of operations
comprising a software integer division could be recognized as such.

128 bits is obviously more than 113 bits, so not every operation can be performed this way.
However, modern optimizing compilers keep track of range constraints of values.

<div class=example>
The optimizer may make the following decisions when performing 128-bit integer division:

- If the divisor is constant, perform strength reduction ([[#fixed-point-operations]]), making the division
    a shift and multiplication.
- If the divisor is a power of two, count the trailing zeros and perform a right-shift.
- Otherwise, if both operands are 2<sup>64</sup>-1 or less, perform 64-bit integer division.
- Otherwise, if one of the operands is 2<sup>64</sup>-1 or less, perform 128-to-64-bit ([[#widening-operations]]) division.
- Otherwise, if both operands are 2<sup>113</sup>-1 or less,
    and if there is hardware support for 128-bit floating point numbers, perform floating-point division.
- [...]
- Otherwise, use a software implementation of 128-bit division.

</div>

ISO C++ does not offer a mechanism through which implementations can be chosen based on
optimizer knowledge.
It also does not offer a mechanism through which it can be detected that a divisor is known to the
optimizer.
What is easy for the implementation is difficult for the user,
which makes it very compelling to provide a built-in type.

Note: Historically, floating-point division in hardware was used to implement integer division.
The x87 circuitry for dividing 80-bit floating-point numbers could be repurposed for 64-bit
integer division.
This strategy is still many times faster than software division.
Intel desktop processors have received dedicated integer dividers starting with Cannon Lake.




# Impact on the standard # {#impact-on-the-standard}

First and foremost, this proposal mandates the following integer types in `<cstdint>`:
```cpp
using int_least128_t  = /* signed integer type */;
using uint_least128_t = /* unsigned integer type */;

using int_fast128_t   = /* signed integer type */;
using uint_fast128_t  = /* unsigned integer type */;

using int128_t = /* signed integer type */; // optional
using uint128_t = /* unsigned integer type */; // optional

// The corresponding macros for MIN and MAX must also be defined ...
```
This change in itself is almost no change at all.
The implementation can already provide `int_least128_t` while complying with the C++11 standard.
Challenges only arise when considering the impact of these new types on the rest of the
standard library, and possibly C compatibility.

Note: A compliant libstdc++ implementation could all aliases as `__int128`.

## C Compatibility ## {#c-compatibility}

Any attempt of standardizing 128-bit integers must also keep possible compatibility with the C
standard in mind.
In particular, `intmax_t` has historically prevented implementations from providing
integer types wider than `long long` without breaking ABI compatibility.
A wider integer type would change the width of `intmax_t`.

C23 has relaxed the definition of `intmax_t`.
[[N3047]], 7.22.1.5 [Greatest-width integer types] currently defines `intmax_t` as follows:

<blockquote>
The following type designates a signed integer type, other than a bit-precise integer type, capable of
representing any value of any signed integer type with the possible exceptions of signed bit-precise
integer types and of signed extended integer types that are wider than `long long` and that are
referred by the type definition for an exact width integer type:
```cpp
intmax_t
```
</blockquote>

For `intmax_t` to not be `int_least128_t`,
there must exist an `int128_t` alias for the same type.
GCC already provides an `__int128` type which satisfies the padding-free requirement and could
be exposed as `int128_t`.

In conclusion, it is possible to provide a `std::int_least128_t` alias with equivalent
semantics in C and C++, and with no ABI break.


## Impact on the core language ## {#core-impact}

The proposal makes no changes to the core language.
However, it is worth noting that the existence of `std::uint_least128_t` leads to some oddities:

- The result of the `sizeof` operator can be a 128-bit integer.
- The underlying type of enumerations can be a 128-bit integer.
- Previously ill-formed integer literals could now be of 128-bit integer type.
- The conditions in `#if` preprocessing directives are evaluated as if operands had the same
    representation as `intmax_t` or `uintmax_t`,
    which means that 128-bit integers cannot be used in this context, or the values
    would be truncated.

However, none of this is a new issue introduced by this proposal.
Any compliant implementation could already have produced this behavior,
assuming it supported 128-bit integers as an optional extended integer type.

While there is certainly software which relies on `std::size_t` and other types not exceeding
64 bits, not defining `std::size_t` to be a 128-bit type is a QoI (Quality of Implementation) issue.
Such problems are not within the scope of the standard.

## Impact on the library ## {#library-impact}

Find below a summary of issues that arise from the introduction of 128-bit integers in the
C++ standard library.
One common issue is that aliases such as `size_type` and `difference_type` within
containers, iterators, and other types can be a 128-bit integer.
The same applies to `std::size_t`, `std::ptrdiff_t`, `std::intmax_t`.

The proposal does not force library maintainers to re-define any of these aliases;
it's just a possibility.
Whether to define them as such is a QoI issue in general, and won't be discussed further.

### Language support library ### {#library-impact-language-support}

**Issue:** `std::div` may need an overload for 128-bit integers.<br>
**Action:** ✔️ No impact on the standard because we don't support it (see [[#div]]).

**Issue:** `std::to_integer` may need 128-bit support.<br>
**Action:** ✔️ No impact on the standard.

**Issue:** `<version>` needs 128-bit integer feature-testing macro.<br>
**Action:** ⚠️ Add macros (see [[#proposed-version]] for wording).

**Issue:** `<numeric_limits>` needs a trait for 128-bit integers.<br>
**Action:** ✔️ No impact on the standard; require a `std::numeric_limits` specialization.

**Issue:** `<climits>` needs additional constants for 128-bit integers.<br>
**Action:** ✔️ No impact on the standard.

**Issue:** `<cstdint>` needs to explicitly require support for 128-bit integers
in its synopsys.<br>
**Action:** ⚠️ Define aliases (see [[#proposed-cstdint]] for wording).

### Metaprogramming library ### {#library-impact-metaprogramming}

**Issue:** `std::is_integral` needs to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard
(see [[#type-traits-implementation-experience]] for implementation experience).

**Issue:** `std::make_signed` and `std::make_unsigned` require 128-bit support.<br>
**Action:** ✔️ No impact on the standard
(see [[#type-traits-implementation-experience]] for implementation experience).

**Issue:** `std::ratio` currently accepts non-type template arguments of `std::intmax_t`.
`std::intmax_t` is no longer the widest integer type and changing the type of NTTP to
`std::uint_least128_t` would be an ABI break because the type of template argument participates
in name mangling.<br>
**Action:** ✔️ No impact on the standard.

Note: Unfortunately, ratios beyond 2<sup>64</sup> or 2<sup>-64</sup>
cannot be represented, assuming that `std::intmax_t` is a 64-bit integer.

### General utilities library ### {#library-impact-utilities}

**Issue:** Integer comparison functions (`std::cmp_equal` et al.) require 128-bit support.
**Action:** ✔️ No impact on the standard
(see [[#safe-comparison-implementation-experience]] for implementation experience).

**Issue:** `std::integer_sequence` needs to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard.

**Issue:** `std::bitset` could receive an additional constructor taking `std::uint_least128_t`.<br>
**Action:** ⚠️ Add such a constructor (see [[#proposed-bitset]] for wording).

**Issue:** `std::bitset` could receive an additional `to_u128` function, similar to `to_ullong`.<br>
**Action:** ⚠️ Add such a function (see [[#proposed-bitset]] for wording).

**Issue:** `std::to_chars` and `std::from_chars` need to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard
(see [[#charconv-implementation-experience]] for implementation experience).

**Issue:** `<format>` needs to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard
(see [[#format-implementation-experience]] for implementation experience).

**Issue:** `basic_format_parse_context::check_dynamic_spec` might need 128-bit integers support.<br>
**Action:** ✔️ No, it doesn't
(see [[#format-implementation-experience]] for implementation experience).

**Issue:** `basic_format_arg` might need support for 128-bit integers.<br>
**Action:** ✔️ No, it doesn't
(see [[#format-implementation-experience]] for implementation experience).

**Issue:** `<bit>` needs to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard
(see [[#bit-implementation-experience]] for implementation experience).

**Issue:** `std::to_string` could support 128-bit types.<br>
**Action:** ⚠️ Add overloads (see [[#proposed-numeric-conversions]] for wording).

### Containers library ### {#library-impact-containers}

**Issue:** The extents and index types of `std::mdspan` could be 128-bit integers.
This is also the case for type aliases of `std::strided_slice`.
The exposition-only helper <code><i>integral-constant-like</i></code> now also includes
128-bit integers.<br>
**Action:** ✔️ No impact on the standard.
All these issues are either QoI or don't impact existing implementations substantially.

### Iterators library ### {#library-impact-iterators}

**Issue:** The exposition-only helper <code><i>integral-constant-like</i></code> now also includes
128-bit integers.
Generally, 128-bit integers would be a valid `difference_type` and an implementation needs to
consider this when defining concepts that use integers in any way.<br>
**Action:** ✔️ No impact on the standard.

Note: As long as `std::is_integral` (and by proxy, `std::integral`) is correct, the existing wording
should be unaffected.


### Ranges library ### {#library-impact-ranges}

**Issue:** <code>std::ranges::iota_view&lt;long long&gt;::<i>iterator</i>::difference_type</code>
is required to be a 128-bit integer if `long long` is not 128-bit, and such a type exists.
This is not the the case in libc++ and MSVC STL at this time,
where `difference_type` is `long long` and `class std::_Signed128` respectively.<br>
**Action:** ❌ Propose changes to prevent breaking ABI
(see [[#iota-view-abi-break]] for discussion and [[#proposed-iota]] for wording).

**Issue:** `std::cartesian_product_view::size` may now return a 128-bit integer.
The standard recommends to use a type which is sufficiently wide to store the product
of sizes of underlying ranges.
A similar issue arises for `std::cartesian_product_view::iterator`.<br>
**Action:** ✔️ No impact on the standard.

Note: The choice of integer type used to be (and still is) implementation-defined.


### Algorithms library ### {#library-impact-algorithms}

**Issue:** `std::gcd`, `std::lcm`, and `std::midpoint` need to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard
(see [[#gcd-implementation-experience]] for implementation experience).

**Issue:** Saturating arithmetic functions and `saturate_cast` need to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard
(see [[#saturating-implementation-experience]] for implementation experience).

### Numerics library ### {#library-impact-numerics}

**Issue:** Various random number generators and `std::uniform_int_distribution` need to support
128-bit types.<br>
**Action:** ✔️ No impact on the standard
(see [[#random-implementation-experience]] for implementation experience).

**Issue:** `std::seed_seq` needs to support `std::initializer_list<std::uint128_t>`.<br>
**Action:** ✔️ No impact on the standard.

**Issue:** `std::valarray` needs to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard (see [[#valarray-implementation-experience]] for implementation experience)

**Issue:** For most `<cmath>` functions, an additional overload taking 128-bit integers would
need to be defined.<br>
**Action:** ✔️ No impact on the standard.

**Issue:** `std::abs` could receive an additional 128-bit overload.<br>
**Action:** ⚠️ Add an overload
(see [[#proposed-abs]] for wording and [[#abs-implementation-experience]] for implementation experience).

**Issue:** The `<linalg>` library needs 128-bit support.<br>
**Action:** ✔️ No impact on the standard
(see [[#linalg-implementation-experience]] for implementation experience).

### Time library ### {#library-impact-time}

**Issue:** Significant portions of `<chrono>` use `std::ratio`, which has `std::intmax_t` template
parameters.<br>
**Action:** ✔️ No impact on the standard.

<div class="note">
<span class="marker">Note:</span>
`std::ratio` cannot represent certain extreme ratios
if `std::intmax_t` is narrower than `std::uint_least128_t`.
However, the time library is generally safe to use, even if the representation of say,
`std::duration` is wider than the types used in a `std::ratio` fraction.
      
If there is future interest, types such as `std::duration`
could be relaxed to work with *ratio-like* types,
so that a new 128-bit `std::ratio`-style type could be used as well,
not just `std::ratio` itself.
However, this is a significant extension of the time library and not part of this proposal.
</div>

### Localization library ### {#library-impact-localization}

**Issue:** `std::num_get` and `std::num_put` could use `std::uint_least128_t` overloads for `do_get`.<br>
**Action:** ✔️ No impact on the standard.

Note: This would be a an ABI break if changes were made.
`std::format` and `std::print` provide sufficient alternatives which can be supported without
breaking ABI.

### Input/output library ### {#library-impact-io}

**Issue:** `std::num_get` and `std::num_put` don't support 128-bit integers.
By proxy, extraction and insertion with `operator>>` would not work.<br>
**Action:** ✔️ No impact on the standard.

Note: The standard doesn't require these to work for all integer types, only for standard integer types.
Any change would be an ABI break, so these facilities could be left untouched.
Unfortunately, the user won't be able to `std::cout << std::uint_least128_t{...}`, however,
the language provides sufficient alternatives.

**Issue:** `std::printf` and `std::scanf` need to support 128-bit integers.<br>
**Action:** ✔️ No impact on the standard.

Note: `PRI*LEAST128` would also need to be defined, but this has no impact on the existing wording.

<div class="example">
With the changes from [[N2680]] included, an alternative way of printing 128-bit
integers is:
```cpp
std::printf("%w128d\n", std::int_least128_t{123});
```
</div>

### Concurrency support library ### {#concurrency-support-library}

**Issue:** `std::atomic` needs to support `std::uint_least128_t`.<br>
**Action:** ✔️ No impact on the standard
(see [[#atomic-implementation-experience]] for implementation experience).

**Issue:** There should be additional aliases `std::atomic_uint_least128_t` et al. aliases.<br>
**Action:** ⚠️ Define aliases
(see [[#proposed-atomic]] for wording).


# Impact on implementations # {#implementation-impact}

## Estimated implementation effort ## {#estimated-implementation-effort}

The following table summarizes the affected standard library parts and the estimated effort
required to implement the proposed changes.

<table>
<tr>
    <th>Affected library part</th><th>Work definitely required</th><th>Impl. experience / Wording</th>
</tr>
<tr>
    <td>`std::to_integer`</td><td>✔️ no</td><td></td>
</tr>
<tr>
    <td>`<version>`</td><td>⚠️ changes proposed</td><td>[[#proposed-version]]</td>
</tr>
<tr>
    <td>`<limits>`</td><td>add specializations</td><td></td>
</tr>
<tr>
    <td>`<climits>`</td><td>add macro constants</td><td></td>
</tr>
<tr>
    <td>`std::is_integral`</td><td>✔️ no</td><td>[[#type-traits-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::make_{un}signed`</td><td>✔️ no</td><td>[[#type-traits-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::cmp_xxx`</td><td>✔️ no</td><td>[[#safe-comparison-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::integer_sequence`</td><td>✔️ no</td><td></td>
</tr>
<tr>
    <td>`std::bitset::bitset`</td><td>⚠️ changes proposed</td><td>[[#proposed-bitset]]</td>
</tr>
<tr>
    <td>`std::bitset::to<T>`</td><td>⚠️ changes proposed</td><td>[[#proposed-bitset]]</td>
</tr>
<tr>
    <td>`<charconv>`</td><td>✔️ no</td><td>[[#charconv-implementation-experience]]</td>
</tr>
<tr>
    <td>`<format>`</td><td>✔️ no</td><td>[[#format-implementation-experience]]</td>
</tr>
<tr>
    <td>`<bit>`</td><td>✔️ no</td><td>[[#bit-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::to_string`</td><td>⚠️ changes proposed</td><td>[[#proposed-numeric-conversions]]</td>
</tr>
<tr>
    <td>`std::iota_view`</td><td>✔️ no</td><td>[[#proposed-iota]]</td>
</tr>
<tr>
    <td>`std::gcd`, `std::lcm`</td><td>✔️ no</td><td>[[#gcd-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::midpoint`</td><td>✔️ no</td><td></td>
</tr>
<tr>
    <td>Saturating arithmetic</td><td>✔️ no</td><td>[[#saturating-implementation-experience]]</td>
</tr>
<tr>
    <td>`<random>` generators</td><td>✔️ no</td><td>[[#random-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::uniform_int_distribution`</td><td>✔️ no</td><td>[[#random-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::seed_seq`</td><td>✔️ no</td><td></td>
</tr>
<tr>
    <td>`std::valarray`</td><td>✔️ no</td><td>[[#valarray-implementation-experience]]</td>
</tr>
<tr>
    <td>`<cmath>` overloads</td><td>add overloads</td><td></td>
</tr>
<tr>
    <td>`std::abs`</td><td>⚠️ changes proposed</td><td>[[#abs-implementation-experience]]</td>
</tr>
<tr>
    <td>`<linalg>`</td><td>✔️ no</td><td>[[#linalg-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::printf`, `std::scanf`</td><td>support 128-bit</td><td></td>
</tr>
<tr>
    <td>`std::atomic` specializations</td><td>✔️ no</td><td>[[#atomic-implementation-experience]]</td>
</tr>
<tr>
    <td>`std::atomic` aliases</td><td>⚠️ changes proposed</td><td>[[#proposed-atomic]]</td>
</tr>
</table>

When deciding *"Work definitely required"*, this paper does not consider menial changes like
relaxing `static_assert(__is_standard_integer<T>)` and such,
which may be present in functions such as `std::gcd`.

Also, if there exists at least one standard library which implements these features,
it is assumed that they can be adapted into other libraries with relative ease.


## ABI break for <code>std::ranges::iota_view::<i>iterator</i>::difference_type</code> ## {#iota-view-abi-break}

libstdc++ defines `difference_type` for `std::ranges::iota_view<long long>` to be `__int128`.
Since a `std::int_least128_t` alias would likely be defined as `__int128`, there is no ABI impact.
Other libraries are not so fortunate.

### Affected implementations ### {#abi-break-affected-implementations}

By contrast, the `difference_type` for `std::ranges::iota_view<long long>` in libc++
is `long long`.

The MSVC STL uses a class type `std::_Signed128`.
Even trivially copyable classes aren't passed via register in the Microsoft x86_64 ABI,
so this type is passed via the stack.
Re-defining this to be an integer type would break ABI, assuming that a Microsoft `__int128`
would be passed via registers.

### Cause of ABI break ### {#abi-break-cause}

The ABI break stems from the fact that <code><i>IOTA-DIFF-T</i>(W)</code>
for `W = long long` is defined to be:

> a signed integer type of width greater than the width of `W` if such a type exists.

Currently, no such type exists, but if `std::int_least128_t` did exist, it would no longer be valid
to use a class type or `long long` as a `difference_type`.

### Possible solution ### {#abi-break-possible-solution}

See [[#proposed-iota]] for a proposed solution which resolves this issue without requiring
action from implementors.

### What about `iota_view<std::int_least128_t>`? ### {#iota-view-128}

Besides the option to provide a &ge; 129-bit `difference_type`,
implementations can also define `difference_type` to be a 128-bit integer.

Neither the *Cpp17RandomAccessIterator* requirement nor the `random_access_iterator` concept
require the difference between two iterators to be representable using their `difference_type`.
Therefore, this is a reasonable strategy which is easy to implement.
Of course, it has the adverse affect that `a - b` is possibly undefined behavior for two iterators.

In practice, will the user ever need a 128-bit `iota_view`, and if so, do they need to represent
such extreme differences?
These are quality-of-implementation issues which maintainers will need to consider.
libstdc++ already supports `std::iota_view<__int128>`, where the `difference_type` is `__int128`.
Besides QoI questions, this proposal does not introduce any new issues.


# Impact on existing code # {#impact-on-existing-code}

With no core language changes and only additional standard library features,
the impact on existing code should be minimal.

## Possible semantic changes ## {#possible-semantic-changes}

However, this idea is put into question when it comes to integer literals.
<div class=example>
<pre>
auto x = 18446744073709551615; // 2<sup>64</sup>-1
</pre>
If the widest signed integer type is a 64-bit type, this code is ill-formed.
Every compiler handles this differently:
- clang declares `x` as `unsigned long long` and emits a warning (compliant).
- GCC declares `x` as `__int128` and emits a misleading warning (compliant).
- MSVC declares `x` as `unsigned long long` and emits no warning (non-compliant).

</div>

The example demonstrates that in practice, introducing a 128-bit integer may
impact some existing code.
To comply with the C++ standard, the type of `18446744073709551615` would have to be
`std::int_least128_t` assuming that `long long` cannot represent the value.

Hexadecimal literals are not affected in the same way because they
are required to be of type `unsigned long long` if `long long` cannot represent the value.
The introduction of a 128-bit integer type would not alter the signedness of existing literals.

## Impact on overload sets ## {#impact-on-overload-sets}

Besides templates, a popular technique for covering multiple integer types is to create an
"exhaustive" overload sets like:
```cpp
// support "all" signed integers (anything less than int is promoted)
void foo(int);
void foo(long);
void foo(long long);
```
I'm putting "exhaustive" in quotes because such code does not cover extended integer types,
which can exist.
Only the implementation knows the whole set of integer types and can ensure completeness.

Note: Creating an overload set from `std::int8_t`, `std::int16_t`, `std::int32_t`,
and `std::int64_t` is not possible because it only covers four out of five standard integer types,
making some calls ambiguous.

While creating sets like these outside of language implementations is not ideal,
the proposal can minimize the impact by making `std::int_least128_t` a distinct type from
standard integer types.
Otherwise, the following code is possibly ill-formed:
```cpp
void foo(long long) { }
void foo(std::int_least128_t) { }
```
If `std::int_least128_t` was the same type as `long long`, this code would be ill-formed
because `foo(long long)` is being defined twice.
There exists no implementation where `long long` is 128-bit, so no code is really affected.
However, there should exist a natural and universally correct way to extend such overload sets,
so that the effort of "upgrading" to 128-bit is minimal.
Therefore `std::int_least128_t` should be distinct.

Guaranteeing that `std::int_least128_t` is distinct means that even if `long long`
is a 128-bit type, it won't be chosen by this alias.
This breaks the conventions of `<cstdint>` and may be surprising,
but no implementation with `<cstdint>` aliases beyond `64` exists,
and no implementation where `long long` is 128-bit exists.
No existing code is affected; this is a purely academic problem.

Note: Another robust way would be to write
`void foo(std::same_as<std::int_least128_t> auto)`.
However, this solution is not obvious, and should not be necessary.


## Possible assumption violations ## {#possible-assumption-violations}

There is obviously a substantial amount of code which assumes that integers are no wider
than 64 bits.
There is also a substantial amount of code which assumes that `std::intmax_t` is
the widest integer type, and this assumption would be broken by introducing `std::uint_least128_t`.

The exact impact is not given an investigation in this proposal.
Assumptions about hardware or integer width limitations cannot hold back language development.
C would be stuck with 32-bit types if that had ever been a convincing rationale.
Also, the introduction of a 128-bit type does not break existing code unless the user chooses
to use it.



# Design considerations # {#design-considerations}

The goal of this proposal is to obtain a mandatory 128-bit type with strong library support.
A `std::least_uint128_t` alias is the only option that does not involve any changes
to the core language.
Therefore, it is the obvious design choice for this proposal.

Note: Unlike the existing `int_leastN_t` and `int_fastN_t` aliases, this type is distinct.
See [[#impact-on-overload-sets]] for rationale, and [[#proposed-cstdint]] for wording.

Besides the current approach, there are a few alternatives which have been considered:

## Why no standard integer type? ## {#standard-integers}

One question that needs addressing is:

> Why standardize a `std::uint_least128_t` type alias but no standard integer type?
> Essentially, why no `unsigned long long long`?

Firstly, naming might be a problem here.
A standard integer type would likely warrant the ability to name it by keyword, and an
ever-increasing sequence of `long`s isn't an attractive solution.
Even with a concise keyword such as `_Uint128`, it is unclear what advantage such a keyword
would have over a type alias, other than saving one `#include` directive.

Secondly, it is useful to keep `std::uint_least128_t` a second-class citizen by not making it a
standard integer type.
For example, in the formatting library, a format string can
specify a dynamic *width* for an argument, which must be a standard integer.
A *width* that cannot be represented by a 64-bit number is unreasonable,
so it makes sense to limit support to standard integers.

Thirdly, as already stated in [[#c-compatibility]], C's `intmax_t` must be the
widest standard integer type.
To not break ABI and be C-compatible, `std::int_least128_t` must be
an extended integer type.

## Why no mandatory `std::int128_t` type? ## {#exact-width-integers}

Mandating any exact `std::intN_t` inadvertently restricts the byte width
because exact-width types cannot have any padding.
`std::int128_t` implies that the width of a byte is a power of two &le; 128,
and historically, C++ has not restricted implementations to a specific byte size.

This decrease in portability also has no good rationale.
If `std::int_least128_t` is mandatory and an implementation is able to define it without padding,
then `std::int128_t` is effectively mandatory.

Hypothetically, a malicious implementation could define `std::int_least128_t` to be a 1000-bit
integer with 872 padding bits, even if it was able to define a padding-free 128-bit integer.
However, malicious implementations have never been a strong argument to guide design.

## Why no `std::int_least256_t` type? ## {#why-no-256-bit}

256-bit integers are also useful and one could use many of the arguments
in favor of 128-bit integers to also propose them.
However, there are are a few strong reasons against including them in this proposal:

1. The wider the bit sizes, the fewer the use cases are.
    For example, 128 bits are sufficient for high-precision clocks and most financial
    applications.
2. There is tremendously less hardware support for 256-bit integers.
    x86 has instructions to perform a 64-to-128-bit multiplication, but no such
    128-to-256-bit instruction exists.
3. There are fewer existing implementations of 256-bit integers.

It is also unclear whether there should ever be a mandatory 256-bit extended integer type,
or if support should be provided through 256-bit bit-precise integers.
Overall, this proposal is more focused if it includes only 128-bit.

Nevertheless, many of the changes in [[#proposed-wording]] pave the way for a future
`std::int_least256_t` or even `std::int_least512_t`.
There would be no wording impact other than defining the necessary aliases and macros.

## Why no bit-precise integers? ## {#bit-precise-integers}

Instead of putting any work into 128-bit integers, it would also be possible to integrate
bit-precise integers (C's `_BitInt(N)` type, proposed in [[N2763]]) into the C++ standard.
Therefore, one may ask:

> Why don't we just standardize `_BitInt(N)` and introduce 128-bit integers that way?

In essence, this is asking:

> Why don't we just build a ten-lane highway instead of a cyclist path?

Firstly, this would be an enormously ambitious and time-intensive undertaking, with huge impact
on the standard.
Secondly, `_BitInt` does not satisfy the goals of this proposal for multiple reasons:

1. `_BitInt` in C23 isn't required to support 128 bits at all (see below).
    Only 64 bits (or as much as `long long` is wide) are required.
    In other words, `_BitInt` doesn't automatically give you 128-bit support.

2. It is not reasonable to expect full library support for any bit size.
    Even C doesn't require `_BitInt` support for its bit-manipulation functions, `printf`, and
    other utilities.
    The C++ standard library dwarfs that of C.
    It is even less realistic to expect full support from all C++ numeric functions,
    input/output facilities etc.
    However, it is realistic to extend library support to *just* 128 bits.

3. Even if library support for specifically 128-bit bit-precise integers was added,
    this would be very strange to specify in the standard.
    Perhaps `_BitInt(128)` would be treated differently from other bit-precise types and given more support from
    `std::format` and other functions, but this would be a somewhat arbitrary type, compared
    to standard integer types, which have minimum sizes, not exact sizes.
    Alternatively, support would be provided through a `_BitInt(N >= 128)` type, but to easily
    refer to it, one would need a `std::bit_int_least128_t` alias
    (Note that defining `int_least128_t = _BitInt(128)` would likely compromise C compatibility).
    At that point, we're just getting `std::int_least128_t` with extra steps.

4. `_BitInt` creates a parallel system to the existing standard and extended integer types.
    Bit-precise integers have different promotion/conversion rules, and may behave differently
    in terms of overload resolution when standardized in C++.
    An extended 128-bit type would integrate more naturally into the existing type system.

### Comparison of bit-precise integers and 128-bit integers ### {#bitint-vs-uint128}

<table>
<tr>
    <th></th><th>Bit-precise integers</th><th>`std::int_least128_t`</td>
</tr>
<tr>
    <th>128-bit support mandatory</th><td>❌</td><td>✔️</td>
</tr>
<tr>
    <th>No core language changes</th><td>❌</td><td>✔️</td>
</tr>
<tr>
    <th>Impl. can guarantee padding-freedom</th><td>❌</td><td>✔️</td>
</tr>
<tr>
    <th>Impl. can guarantee 2<sup>N</sup> width</th><td>❌</td><td>✔️</td>
</tr>
<tr>
    <th>Low implementation effort (built-in)</th><td>❌</td><td>❌</td>
</tr>
<tr>
    <th>Low implementation effort (library)</th><td>❌</td><td>✔️</td>
</tr>
<tr>
    <th>Integrates easily into the<br>existing system of standard integers</th><td>❌</td><td>✔️</td>
</tr>
<tr>
    <th>Strong C library support required</th><td>❌</td><td>✔️</td>
</tr>
</table>


Note: The C23 standard currently does not mandate "full" library support for bit-precise integers.
For example, `printf` would require a `PRIuLEASTN` format specifier macro to print `uint_least128_t`,
but the existence of `_BitInt(128)` does not imply the existence of `uint_least128_t` or such
a macro.

## Why not make it optional? ## {#why-not-optional}

Instead of making `std::int_least128_t` entirely mandatory, it would also be possible to
make it an optional type, or to make it mandatory only on hosted implementations.
This idea may be motivated by two potential issues:

> On freestanding/embedded platforms, the implementation effort of `std::int_least128_t` is too great.

While this concern is valid, C23 requires arbitrary-precision arithmetic through `_BitInt` anyway
and GCC and clang support `_BitInt(128)` already (see [[#existing-bit-int]] for support).
Assuming that vendors care about C-compatibility,
this proposal merely requires vendors to provide `int_least128_t = _BitIntLike(128)`.

Note: `int_least128_t = _BitInt(128)` would be incompatible with the C standard.

The remaining impact is limited to the standard library, and it's almost always possible to
generalize algorithms to an arbitrary bit size.
This is especially easy when the implementation can ensure that all integers are padding-free
and have a size that is a 2<sup>N</sup> multiple of the byte size.
Only `int_leastN_t` is mandatory (not the exact-width types),
so the implementation can ensure it.

> `std::int_least128_t` should not be mandatory if it's too slow.

There is also merit to this concern.
A mandatory type may give the user a false sense of hardware support which simply
doesn't exist, especially on 32-bit or even 8-bit hardware.

However, this problem is innate to standard integers as well.
If a user is compiling for a 32-bit architecture, a 64-bit `long long` will have to be
software-emulated, and 64-bit integer division can have dramatic cost.
Why should a 64-bit `long long` be mandatory on an 8-bit architecture?
The answer is: because it's useful to rely on `long long` so we can write portable code,
even if we try to avoid the type for the sake of performance.

In the end, it's the responsibility of the user to be vaguely aware of hardware capabilities
and not use integer types that are poorly supported.
If the user wants to perform a 128-bit integer division on an 8-bit machine,
the language shouldn't artificially restrict them from doing so.
The same principle applies to `long long`, `std::int_least128_t`, C23's `_BitInt(1024)`, etc.


## Why no `std::div`? ## {#div}

`std::div` is a function which returns the quotient and remainder of an integer division in one
operation.
This proposal intentionally doesn't extend support to 128-bit types because each overload of
`std::div` returns a different type.
Namely, the current overloads for `int`, `long`, and `long long`
return `std::div_t`, `std::ldiv_t`, and `std::lldiv_t` respectively.

This scheme isn't easy to generalize to 128-bit integers or other extended integer types.
A possibly approach would be to define a class template `std::div_result<T>` and re-define
the concrete types to be aliases for `std::div_result<int>` etc.
However, this is arguably a breaking change because it alters what template argument deduction
is possible from these types.

Furthermore, `std::div` is arguably useless.
Optimizing compilers recognize separate uses of `x / y` and `x % y` and fuse them into a single
division which yields both quotient and remainder, at least on platforms where this is possible.
There is no motivation for putting substantial work into a useless relic.


# Implementation experience # {#implementation-experience}

## Existing 128-bit integer types ## {#existing-128-bit-integers}

### `__int128` (GNU-like) ### {#existing-int-128}

GCC and clang already provide the 128-bit integer types in the form of
`__int128` and `unsigned __int128`.
However, this type is not available when compiling for 32-bit targets.
Clang provides the same support.

### `__int128` (CUDA) ### {#existing-int-128-cuda}

In NVIDIA CUDA 11.5, the NVCC compiler has added preview support for the
signed and unsigned `__int128` data types on platforms where the host compiler supports it.
See [[NVIDIA]].

### `std::_Signed128`, `std::_Unsigned128` ### {#existing-msvc-128}

The MSVC STL provides the class types `std::_Signed128` and `std::_Unsigned128` defined in
<a href="https://github.com/microsoft/STL/blob/main/stl/inc/__msvc_int128.hpp">`<__msvc_int128.hpp>`</a>.
These types implement all arithmetic operations and integer comparisons.

They satisfy the *integer-like* constraint and have been added to implement
[[P1522R1]].
`std::iota_view::difference_type` is possibly defined as `std::_Signed128`.

### `_BitInt(128)` ### {#existing-bit-int}

The C23 standard requires support for bit-precise integers
`_BitInt(N <= BITINT_MAXWIDTH)` where `BITINT_MAXWIDTH >= ULLONG_WIDTH`.
While this doesn't strictly force support for 128-bit integers,
GNU-family implementations support more than 128 bits already.

As of February 2024, the support is as follows:
<table>
<tr>
    <th>Compiler</th><th>`BITINT_MAXWIDTH`</th><th>Targets</th>
</tr>
<tr>
    <td>clang 14</td><td>`128`</td><td>all</td>
<tr>
</tr>
    <td>clang 16</td><td>`8388608`</td><td>all</td>
<tr>
</tr>
    <td>GCC 14</td><td>`65535`</td><td>64-bit only</td>
<tr>
</tr>
    <td>MSVC 19.38</td><td>❌</td><td>❌</td>
</tr>
</table>

Note: clang has supported `_BitInt` as an `_ExtInt` compiler extension prior to C standardization.

It is possible that given enough time, `_BitInt(128)` will be
supported by Microsoft as well.

Note: Microsoft Developer Community users have requested support for a 128-bit type
at [[MSDN]].


## Library implementation experience ## {#library-implementation-experience}

### `<type_traits>` ### {#type-traits-implementation-experience}

Assuming that `is_integral` and `make_{un}signed` don't simply delegate to a compiler intrinsic,
implementing these traits merely requires adding two specializations such as
`is_integral<int_least128_t> : false_type`.

See libstdc++'s <a href="https://github.com/gcc-mirror/gcc/blob/93e1559bea434a681208e5e7a21513d7da2844d6/libstdc%2B%2B-v3/include/std/type_traits">`<type_traits>`</a>.

### `std::cmp_xxx` ### {#safe-comparison-implementation-experience}

Libstdc++ provides a width-agnostic implementation of `std::cmp_equal` and other safe comparison functions in
<a href="https://github.com/gcc-mirror/gcc/blob/93e1559bea434a681208e5e7a21513d7da2844d6/libstdc%2B%2B-v3/include/std/utility#L127">`<utility>`</a>.

Being able to extend to a wider type is helpful in principle (e.g. implementing `std::cmp_equal(int, int)` in terms of a comparison between `long`s),
however, the current implementations don't make use of this opportunity anyway.

### `<charconv>` ### {#charconv-implementation-experience}

libstdc++ already provides a width-agnostic implementation
of `std::to_chars` in
<a href="https://github.com/gcc-mirror/gcc/blob/cff174fabd6c980c09aee95db1d9d5c22421761f/libstdc%2B%2B-v3/include/bits/charconv.h">`<bits/charconv.h>`</a>,
and a width-agnostic implementation of `std::from_chars` in 
<a href="https://github.com/gcc-mirror/gcc/blob/cff174fabd6c980c09aee95db1d9d5c22421761f/libstdc%2B%2B-v3/include/std/charconv">`<charconv>`</a>.

In general, it is not difficult to generalize `std::to_chars` for any width.
Stringification uses integer division, which may be a problem.
However, the divisor is constant.
Due to strength reduction optimization (see [[#fixed-point-operations]] for an example),
no extreme cost is incurred no matter the width.

### `<format>` ### {#format-implementation-experience}

libstdc++ already supports `std::format` for `__int128`.

The locale-independent forms are simply implemented in terms of `std::to_chars` and are not
affected by the introduction of 128-bit integers.
As explained above, `std::to_chars` implementations typically already support 128-bit integers.

The new `std::basic_format_parse_context::check_dynamic_spec` function is not affected.
This function only checks for the type of a dynamic *width* or *precision*, and the arguments are required to be of standard integer type.
Realistically the user will never need a 128-bit *width* or *precision*,
which is why no changes are proposed.

`std::basic_format_arg` also requires no changes because `std::basic_format_arg::handle`
already covers extended integer and floating-point types.
Also, modifying the `value` `variant` within a `std::basic_format_arg`
would be an avoidable ABI-break.

### `<bit>` ### {#bit-implementation-experience}

In [[BitPermutations]], I have implemented the majority of C++ bit manipulation functions
for *any* width, i.e. in a way that is compatible with `_BitInt(N)` for any `N`.

Such an extremely generalized implementation is challenging, however, merely extending support
to 128-bit given a 64-bit implementation is simple.

<div class=example>
Given a 64-bit `std::popcount`, a 128-bit implementation looks as follows:
```cpp
int popcount(uint128_t x) {
    return popcount(uint64_t(x >> 64)) + popcount(uint64_t(x));
}
```
</div>

<div class=example>
Given a 64-bit `std::countr_zero`, a 128-bit implementation looks as follows:
```cpp
int countr_zero(uint128_t x) {
    int result = countr_zero(uint64_t(x));
    return result < 64 ? result : 64 + countr_zero(uint64_t(x >> 64));
}
```
</div>

All bit manipulation functions are easily constructed this way.

### `std::gcd`, `std::lcm` ### {#gcd-implementation-experience}

libstdc++ provides a
<a href="https://github.com/gcc-mirror/gcc/blob/cff174fabd6c980c09aee95db1d9d5c22421761f/libstdc%2B%2B-v3/include/std/numeric#L134">`std::gcd`</a>
implementation which uses the [Binary GCD algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm).
The MSVC STL has a similar implementation.
This algorithm is easily generalized to any width.
It requires `std::countr_zero` for an efficient implementation, which is easy to implement
for 128-bit integers, as mentioned above.

libc++ uses a naive
<a href="https://github.com/llvm/llvm-project/blob/b17348c3b541d7fc7ec441c98db75c18d8959910/libcxx/include/__numeric/gcd_lcm.h#L53">`std::gcd`</a>
implementation based on the Euclidean Algorithm, which relies on integer division.
Due to the immense cost of integer division for 128-bit integers,
such an implementation may need revision.

`std::lcm` requires no work because mathematically, `gcd(x, y) * lcm(x, y) == x * y`.
The implementation effort (if any) is limited to `std::gcd`.

### `<random>` ### {#random-implementation-experience}

`std::linear_congruential_engine<T, a, c, m>` requires at least double-wide integers
to safely perform the operation `(a * x + c) mod m`, where `x` is the LCG state.
Otherwise, the multiplication and addition could overflow.

libstdc++ solves this issue by performing all operations using `__int128` if available
(see
<a href="https://github.com/gcc-mirror/gcc/blob/67d5b10e659c3f4c02b8af507c84d5e764e264b4/libstdc%2B%2B-v3/include/bits/random.h#L83">`<bits/random.h>`</a>),
and otherwise:
```cpp
static_assert(__which < 0, /* needs to be dependent */
    "sorry, would be too much trouble for a slow result");
```

Introducing 128-bit integers would force implementations to also provide 256-bit operations
solely for the purpose of `std::linear_congruential_engine`.
This can be considered reasonable because C23 requires implementations to provide
arbitrary-precision arithmetic anyway, and both GCC and clang already implement
`_BitInt(N)` for `N >= 256` (see [[#existing-bit-int]] for details on support).


### Saturating arithmetic ### {#saturating-implementation-experience}

libstdc++ provides a width-agnostic implementation for all saturating arithmetic functions in
<a href="https://github.com/gcc-mirror/gcc/blob/cff174fabd6c980c09aee95db1d9d5c22421761f/libstdc%2B%2B-v3/include/bits/sat_arith.h">`<bits/sat_arith.h>`</a>.

Saturating arithmetic is generally done through compiler intrinsics such as
`__builtin_mul_overflow`.
These are already supported by GCC and Clang.
A software implementation of overflow detection may be very tedious as explained in
[[P0543R3]], but that isn't the chosen implementation anyway.

### `std::abs` ### {#abs-implementation-experience}

`std::abs` can be easily implemented width-agnostically as `x >= 0 ? x : -x`
for any integer `x`.

Note that an overload must exist for every integer type to avoid calling `std::abs` for
floating-point types.
Such an overload is proposed in [[#proposed-abs]].

### `std::valarray` ### {#valarray-implementation-experience}

`std::valarray<T>` does not rely on any specific bit-size, or on `T` being any
type in general.
While it is possible to provide specializations for specific types that make
more optimal use of hardware, it is also possible to rely on the
optimizers auto-vectorization capabilities alone.

### `<linalg>` ### {#linalg-implementation-experience}

The linear algebra library introduced by [[P1673R13]] does not rely on any specific widths and
is generalized by default.
The corresponding [reference implementation](https://github.com/kokkos/stdBLAS) can operate on
`__int128`.

Providing specializations for specific widths is a quality-of-implementation issue.

### `std::atomic` ### {#atomic-implementation-experience}

Libc++ already provides support for fetch-operations for `std::atomic<__int128>`.
For example, `.fetch_add` delegates to `__atomic_fetch_add_16` in libatomic.

In general, the `fetch` operations that `std::atomic<long long>` provides
must already have a software fallback for 32-bit hardware, where no 64-bit
atomic `add` instruction exists.
Such a software fallback may be implemented as a
[CAS-and-retry](https://en.wikipedia.org/wiki/Compare-and-swap) loop.
The introduction of 128-bit integers adds no new challenges.



# Proposed wording # {#proposed-wording}

<style>
@media (prefers-color-scheme: dark) {
  c-[mb], c-[mi], c-[mo], c-[mh] {
    color: #d59393 !important;
  }

  blockquote c-[mb], blockquote c-[mi], blockquote c-[mh] {
    color: var(--text) !important;
  }
}

th, td, table {
    border: 1px solid var(--text);
}
th, td {
    border-left-width: 0;
    border-right-width: 0;
}

.indent {
    margin-left: 2em;
}

svg {
    background: none;
    vertical-align: middle;
}

ins {
    background: rgba(136, 255, 93, 0.2);
    color: inherit;
    text-decoration: underlined;
}
del {
    background: rgba(255, 93, 93, 0.2);
    color: inherit;
    text-decoration: strikethrough;
}
</style>

The proposed wording is relative to [[!CxxDraft]], accessed 2024-02-10.

## Header `<version>` ## {#proposed-version}

In subclause 17.3.2 [version.syn], update the feature-testing macros as follows:

<blockquote>
<pre>
<ins>#define __cpp_lib_atomic_int128    20XXXX</ins>
#define __cpp_lib_bitset    <del>202306L</del><ins>20XXXX</ins>
<ins>#define __cpp_lib_bitset_int128    20XXXX</ins>
<ins>#define __cpp_lib_int128           20XXXX</ins>
#define __cpp_lib_to_string <del>202306L</del><ins>20XXXX</ins>
<ins>#define __cpp_lib_to_string_int128 20XXXX</ins>
</pre>
</blockquote>

Note: Feature-detection for `std::printf` and `std::scanf` is intentionally omitted
because the user can detect whether `PRI*LEAST128`, `SCN*FAST128` etc. are defined.

## Header `<cstdint>` ## {#proposed-cstdint}

In subclause 17.4.1 [cstdint.syn], update the synopsis as follows:

<blockquote>
<pre>
// all freestanding
namespace std {
  using int8_t          = <i>signed integer type</i>;    // optional
  using int16_t         = <i>signed integer type</i>;    // optional
  using int32_t         = <i>signed integer type</i>;    // optional
  using int64_t         = <i>signed integer type</i>;    // optional
  <ins>using int128_t        = <i>signed integer type</i>;    // optional</ins>
  using intN_t          = <i>see below</i>;              // optional

  using int_fast8_t     = <i>signed integer type</i>;
  using int_fast16_t    = <i>signed integer type</i>;
  using int_fast32_t    = <i>signed integer type</i>;
  using int_fast64_t    = <i>signed integer type</i>;
  <ins>using int_fast128_t   = <i>signed integer type</i>;</ins>
  using int_fastN_t     = <i>see below</i>;              // optional

  using int_least8_t    = <i>signed integer type</i>;
  using int_least16_t   = <i>signed integer type</i>;
  using int_least32_t   = <i>signed integer type</i>;
  using int_least64_t   = <i>signed integer type</i>;
  <ins>using int_least128_t  = <i>signed integer type</i>;</ins>
  using int_leastN_t    = <i>see below</i>;              // optional

  using intmax_t        = <i>signed integer type</i>;
  using intptr_t        = <i>signed integer type</i>;    // optional

  using uint8_t         = <i>unsigned integer type</i>;  // optional
  using uint16_t        = <i>unsigned integer type</i>;  // optional
  using uint32_t        = <i>unsigned integer type</i>;  // optional
  using uint64_t        = <i>unsigned integer type</i>;  // optional
  <ins>using uint128_t       = <i>unsigned integer type</i>;  // optional</ins>
  using uintN_t         = <i>see below</i>;              // optional

  using uint_fast8_t    = <i>unsigned integer type</i>;
  using uint_fast16_t   = <i>unsigned integer type</i>;
  using uint_fast32_t   = <i>unsigned integer type</i>;
  using uint_fast64_t   = <i>unsigned integer type</i>;
  <ins>using uint_fast128_t  = <i>unsigned integer type</i>;</ins>
  using uint_fastN_t    = <i>see below</i>;              // optional

  using uint_least8_t   = <i>unsigned integer type</i>;
  using uint_least16_t  = <i>unsigned integer type</i>;
  using uint_least32_t  = <i>unsigned integer type</i>;
  using uint_least64_t  = <i>unsigned integer type</i>;
  <ins>using uint_least128_t = <i>unsigned integer type</i>;</ins>
  using uint_leastN_t   = <i>see below</i>;              // optional

  using uintmax_t       = <i>unsigned integer type</i>;
  using uintptr_t       = <i>unsigned integer type</i>;  // optional
}
</pre>
</blockquote>

In subclause 17.4.1 [cstdint.syn], update paragraph 3 as follows:

<blockquote>
All types that use the placeholder *N* are optional when *N* is not
`8`, `16`, `32`, <del>or</del> `64`<ins>, or `128`</ins>.
The exact-width types `intN_t` and `uintN_t` for *N* =
`8`, `16`, `32`, <del>and</del> `64`<ins>, and `128`</ins>
are also optional;
however, if an implementation defines integer types with the corresponding width and no padding bits,
it defines the corresponding *typedef-name*s.
Each of the macros listed in this subclause is defined
if and only if the implementation defines the corresponding *typedef-name*.
</blockquote>

In subclause 17.4.1 [cstdint.syn], add the following paragraph:
<blockquote>
<ins>None of the types that use the placeholder *N* are standard integers types ([basic.fundamental])
if *N* is greater than 64.
<br>[*Example*: `int_least128_t` is an extended integer type.
`int_least64_t` is an extended integer type or a standard integer type whose width is at least 64.  — *end example*]
</ins>
</blockquote>

Note: This restriction is intended to address [[#impact-on-overload-sets]].

## Class template `bitset` ## {#proposed-bitset}

In subclause 22.9.2.1 [template.bitset.general], update the synopsis as follows:
<blockquote>
<pre>
    // [bitset.cons], constructors
    constexpr bitset() noexcept;
<del>    constexpr bitset(unsigned long long val) noexcept;</del>
<ins>    constexpr bitset(<i>unsigned-integer-least-llong</i> val) noexcept;</ins>
[...]
    constexpr unsigned long        to_ulong() const;
    constexpr unsigned long long   to_ullong() const;
<ins>    template&lt;class T&gt;
      constexpr T to() const;</ins>
</pre>
</blockquote>

In subclause 22.9.2.2 [template.bitset.const], update the constructors as follows:
<blockquote>
<pre>
<del>constexpr bitset(unsigned long long val) noexcept;</del>
<ins>constexpr bitset(<i>unsigned-integer-least-llong</i> val) noexcept;</ins>
</pre>
<p class="indent">
<ins>The implementation provides one overload for every unsigned integer type whose
conversion rank is that of `unsigned long long` or greater.</ins>
</p>
<p class="indent">
*Effects*: Initializes the first `M` bit positions to the corresponding bit values in val.
`M` is the smaller of `N` and the number of bits in the value representation
([basic.types.general]) of <del>`unsigned long long`</del><ins>the type of `val`</ins>.
If `M < N`, the remaining bit positions are initialized to zero.
</p>
</blockquote>

Note: It is possible that `unsigned long long` is the same type
as `uint_least128_t`, so the mandate is necessary to prevent a duplicate definition.

In subclause 22.9.2.3 [bitset.members], make the following changes:

<blockquote>
<pre>
<del>constexpr unsigned long to_ulong() const;</del>
</pre>
<p class="indent">
<del>*Returns*: `x`.</del>
</p>
<p class="indent">
<del>*Throws*: `overflow_error` if the integral value `x` corresponding to the bits in `*this`
cannot be represented as type `unsigned long`.</del>
</p>
<pre>
<del>constexpr unsigned long long to_ullong() const;</del>
<ins>constexpr unsigned long      to_ulong() const;</ins>
<ins>constexpr unsigned long long to_ullong() const;</ins>
<ins>template&lt;class T&gt;
<ins>  constexpr T to() const;</ins>
</pre>
<p class="indent">
<ins>*Constraints*: `T` is an unsigned integer type ([basic.fundamental]).</ins>
</p>
<p class="indent">
*Returns*: `x`.
</p>
<p class="indent">
*Throws*: `overflow_error` if the integral value `x` corresponding to the bits in `*this`
cannot be represented as <del>type `unsigned long long`</del><ins>the return type</ins>.
</p>
</blockquote>

## Numeric conversions ## {#proposed-numeric-conversions}

Wording for `to_string` requires no changes after [[Schultke1]].
However, should those changes not be accepted,
update subclause 23.4.2 [string.syn] as follows:

<blockquote>
<pre>
<del>
  string to_string(int val);
  string to_string(unsigned val);
  string to_string(long val);
  string to_string(unsigned long val);
  string to_string(long long val);
  string to_string(unsigned long long val);
  string to_string(int_least128_t);</del>
<ins>  string to_string(<i>integer-least-int</i> val);</ins>
  string to_string(float val);
  string to_string(double val);
  string to_string(long double val);
</pre>
</blockquote>

Under the same condition, in subclause 23.4.5 [string.conversions], update `to_string`:
<blockquote>
<pre>
<del>  string to_string(int val);
  string to_string(unsigned val);
  string to_string(long val);
  string to_string(unsigned long val);
  string to_string(long long val);
  string to_string(unsigned long long val);</del>
<ins>  string to_string(<i>integer-least-int</i> val);</ins>
  string to_string(float val);
  string to_string(double val);
  string to_string(long double val);
</pre>
<p class="indent">
<ins>The implementation provides one overload for every integer type whose
conversion rank is that of `int` or greater.</ins>
</p>
<p class="indent">
*Returns*: `format("{}", val)`.
</p>
</blockquote>

## Iota view ## {#proposed-iota}

In subclause 26.6.4.2 [ranges.iota.view], update paragraph 1 as follows:
<blockquote>
Let <code><i>IOTA-DIFF-T(W)</i></code> be defined as follows:
- If `W` is not an integral type, or if it is an integral type and `sizeof(iter_difference_t<W>)`
    is greater than `sizeof(W)`, then <code><i>IOTA-DIFF-T(W)</i></code> denotes `iter_difference_t<W>`.
- Otherwise, <code><i>IOTA-DIFF-T(W)</i></code> is a signed <ins>standard</ins> integer type of width greater than the width of `W` if such a type exists.
- Otherwise, <code><i>IOTA-DIFF-T(W)</i></code> is an unspecified signed-integer-like type ([iterator.concept.winc]) of width not less than the width of `W`.
    <br>[*Note* 1: It is unspecified whether this type satisfies `weakly_incrementable`.
    — *end note*]

</blockquote>

Note: This change resolves the potential ABI break explained in [[#iota-view-abi-break]].
This change purely increases implementor freedom.
An extended integer type still models signed-integer-like, so GCC's existing implementation
using `__int128` remains valid.
However, a wider extended integer type is no longer the mandatory difference type (if it exists)
as per the second bullet.

## Absolute values ## {#proposed-abs}

In subclause 28.7.1 [cmath.syn], update the synopsis as follows:
<blockquote>
<pre>
  // [c.math.abs], absolute values
<del>  constexpr int abs(int j);                                         // freestanding
  constexpr long int abs(long int j);                               // freestanding
  constexpr long long int abs(long long int j);                     // freestanding</del>
<ins>  constexpr auto abs(<i>signed-integer-least-int</i> j) -> decltype(j);    // freestanding</ins>
  constexpr <i>floating-point-type</i> abs(<i>floating-point-type</i> j);         // freestanding-deleted
</pre>
</blockquote>

In subclause 28.7.2 [c.math.abs], make the following changes:
<blockquote>
<pre>
<del>constexpr int abs(int j);
constexpr long int abs(long int j);
constexpr long long int abs(long long int j);</del>
<ins>constexpr auto abs(<i>signed-integer-least-int</i> j) -> decltype(j);</ins>
</pre>
<p class="indent">
<ins>The implementation provides one overload for every signed integer type whose
conversion rank is that of `int` or greater.</ins>
</p>
<p class="indent">
<del>*Effects*: These functions have the semantics specified in the C standard library for the functions `abs`, `labs`, and `llabs`, respectively.</del>
<ins>*Returns*: `j >= 0 ? j : -j;`.
</p>
</blockquote>

## Atomic operations ## {#proposed-atomic}

In subclause 33.5.2 [atomics.syn], update the synopsis as follows:

<blockquote>
<pre>
// all freestanding
namespace std {
  [...]

  using atomic_int8_t         = atomic&lt;int8_t&gt;;           // freestanding
  using atomic_uint8_t        = atomic&lt;uint8_t&gt;;          // freestanding
  using atomic_int16_t        = atomic&lt;int16_t&gt;;          // freestanding
  using atomic_uint16_t       = atomic&lt;uint16_t&gt;;         // freestanding
  using atomic_int32_t        = atomic&lt;int32_t&gt;;          // freestanding
  using atomic_uint32_t       = atomic&lt;uint32_t&gt;;         // freestanding
  using atomic_int64_t        = atomic&lt;int64_t&gt;;          // freestanding
  using atomic_uint64_t       = atomic&lt;uint64_t&gt;;         // freestanding
<ins>  using atomic_int128_t       = atomic&lt;int128_t&gt;;         // freestanding</ins>
<ins>  using atomic_uint128_t      = atomic&lt;uint128_t&gt;;        // freestanding</ins>

  using atomic_int_least8_t   = atomic&lt;int_least8_t&gt;;     // freestanding
  using atomic_uint_least8_t  = atomic&lt;uint_least8_t&gt;;    // freestanding
  using atomic_int_least16_t  = atomic&lt;int_least16_t&gt;;    // freestanding
  using atomic_uint_least16_t = atomic&lt;uint_least16_t&gt;;   // freestanding
  using atomic_int_least32_t  = atomic&lt;int_least32_t&gt;;    // freestanding
  using atomic_uint_least32_t = atomic&lt;uint_least32_t&gt;;   // freestanding
  using atomic_int_least64_t  = atomic&lt;int_least64_t&gt;;    // freestanding
  using atomic_uint_least64_t = atomic&lt;uint_least64_t&gt;;   // freestanding
<ins>  using atomic_int_least128_t  = atomic&lt;int_least128_t&gt;;  // freestanding</ins>
<ins>  using atomic_uint_least128_t = atomic&lt;uint_least128_t&gt;; // freestanding</ins>

  using atomic_int_fast8_t    = atomic&lt;int_fast8_t&gt;;      // freestanding
  using atomic_uint_fast8_t   = atomic&lt;uint_fast8_t&gt;;     // freestanding
  using atomic_int_fast16_t   = atomic&lt;int_fast16_t&gt;;     // freestanding
  using atomic_uint_fast16_t  = atomic&lt;uint_fast16_t&gt;;    // freestanding
  using atomic_int_fast32_t   = atomic&lt;int_fast32_t&gt;;     // freestanding
  using atomic_uint_fast32_t  = atomic&lt;uint_fast32_t&gt;;    // freestanding
  using atomic_int_fast64_t   = atomic&lt;int_fast64_t&gt;;     // freestanding
  using atomic_uint_fast64_t  = atomic&lt;uint_fast64_t&gt;;    // freestanding
<ins>  using atomic_int_fast128_t  = atomic&lt;int_fast128_t&gt;;    // freestanding</ins>
<ins>  using atomic_uint_fast128_t = atomic&lt;uint_fast128_t&gt;;   // freestanding</ins>

  [...]
}
</pre>
</blockquote>


<pre class=biblio>
{
    "BitPermutations": {
        "title": "C++26 Bit Permutations",
        "href": "https://github.com/Eisenwave/cxx26-bit-permutations",
        "authors": ["Jan Schultke et al."]
    },
    "CxxDraft": {
        "title": "C++ Standard Draft",
        "href": "https://github.com/cplusplus/draft/commit/8238252bcec14f76e97133db32721beaec5c749b",
        "authors": ["VA"]
    },
    "Dragonbox": {
        "title": "Dragonbox: A New FLoating-Point Binary-to-Decimal Conversion Algorithm",
        "href": "https://github.com/jk-jeon/dragonbox/blob/master/other_files/Dragonbox.pdf",
        "authors": ["Junekey Jeon"]
    },
    "fast_float": {
        "title": "fast_float number parsing library: 4x faster than strtod",
        "href": "https://github.com/fastfloat/fast_float",
        "authors": ["Daniel Lemire et al."]
    },
    "TigerBeetle": {
        "title": "64-Bit Bank Balances ‘Ought to be Enough for Anybody’?",
        "href": "https://tigerbeetle.com/blog/2023-09-19-64-bit-bank-balances-ought-to-be-enough-for-anybody/",
        "authors": ["Rafael Batiati"]
    },
    "libdivide": {
        "title": "libdivide",
        "href": "https://github.com/ridiculousfish/libdivide",
        "authors": ["Kim Walisch et al."]
    },
    "Marsaglia": {
        "title": "Xorshift RNGs",
        "href": "https://www.jstatsoft.org/article/download/v008i14/916",
        "authors": ["George Marsaglia"]
    },
    "MSDN": {
        "title": "Support for 128-bit integer type",
        "href": "https://developercommunity.microsoft.com/t/Support-for-128-bit-integer-type/879048",
        "authors": ["Colen Garoutte-Carson et al." ]
    },
    "N2680": {
        "title": "Specific width length modifier",
        "href": "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2680.pdf",
        "authors": ["Robert C. Seacord"]
    },
    "N2763": {
        "title": "Adding a Fundamental Type for N-bit integers",
        "href": "https://open-std.org/JTC1/SC22/WG14/www/docs/n2763.pdf",
        "authors": ["Aaron Ballman", "Melanie Blower", "Tommy Hoffner", "Erich Keane"]
    },
    "N3047": {
        "title": "N3047 working draft — August 4, 2022 ISO/IEC 9899:2023 (E)",
        "href": "https://www.iso-9899.info/n3047.html",
        "authors": ["ISO"]
    },
    "NVIDIA": {
        "title": "Implementing High-Precision Decimal Arithmetic with CUDA int128",
        "href": "https://developer.nvidia.com/blog/implementing-high-precision-decimal-arithmetic-with-cuda-int128/",
        "authors": ["Conor Hoekstra", "Kuhu Shukla", "Mark Harris"]
    },
    "RISC-V": {
        "title": "The RISC-V Instruction Set Manual - Volume I: Unprivileged ISA",
        "href": "https://drive.google.com/file/d/1s0lZxUZaa7eV_O0_WsZzaurFLLww7ou5/view",
        "authors": ["VA"]
    },
    "Schultke1": {
        "title": "Better, constexpr to_string",
        "href": "https://eisenwave.github.io/cpp-proposals/constexpr-to-string.html",
        "authors": ["Jan Schultke"]
    },
    "SEC": {
        "title": "Division of Market Regulation: Responses to Frequently Asked Questions Concerning Rule 612 (Minimum Pricing Increment) of Regulation NMS",
        "href": "https://www.sec.gov/divisions/marketreg/subpenny612faq.htm",
        "authors": ["U.S. Securities and Exchange Commission"]
    },
    "Wikipedia": {
        "title": "Quadruple-precision floating-point format - Hardware support",
        "href": "https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Hardware_support",
        "authors": ["VA"]
    }
}
</pre>