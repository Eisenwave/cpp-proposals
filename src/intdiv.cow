\import{libwg21.cow}

\wg21-head[
    title = Integer division
]{
\dl{
    \dt{Document number:} \dd{\docnum{P3724R0}}
    \dt{Date:}            \dd{\tt{2025-06-04}}
    \dt{Audience:}        \dd{LEWG, SG6}
    \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages â€” C++, ISO/IEC JTC1/SC22/WG21}
    \dt{Reply-To:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
    \dt{GitHub Issue:}    \dd{\ref[https://wg21.link/P3724/github]}
    \dt{Source:}          \dd{\ref[https://github.com/Eisenwave/cpp-proposals/blob/master/src/intdiv.cow]}
}
\hr
}

\Babstract{
C++ currently only offers truncating integer division in the form of the \tcode{/} operator.
I propose standard library functions for computing quotients and remainders
with other rounding modes.
}

\h2[listed=no]{Contents}

\make-contents

\h2{Introduction}

C++ currently only offers truncating integer division in the form of the \tcode{/} operator.
However, other rounding modes have various use cases too,
and implementing these as the user can be surprisingly hard,
especially when integer overflow needs to be avoided,
and negative inputs are accepted.

Furthermore, since the \tcode{/} operator rounds towards zero,
the \tcode{\N{PERCENT SIGN}} (remainder) operator may yield negative results
(specifically, when the dividend is negative).
In modular arithmetic and various other use cases,
this is undesirable,
and a negative remainder may be surprising in general.

Therefore, I propose a set of standard library functions
which implement a variety of rounding modes when computing quotients and remainders.
Such a feature was previously part of \ref[P0105R1] and the Numerics TS \ref[P1889R1],
but was eventually abandoned by the author.

\Bnote{
Terminology refresher for division, where
\math{\mi[style=font-style:italic]{round}}
is some rounding function:
\mathblock{\mrow{
    \mi{quotient}
    \mo{=}
    \mi[style=font-style:italic]{round}
    \mo{(}
    \mfrac{\mi{dividend}\mi{divisor}}
    \mo{)}
    \mo{+}
    \mi{remainder}
}}
Your browser requires MathML support to view the equation above.
}

\h3{Existing practice}

To better put this proposal into context,
it is relevant to know what rounding modes are usually supported by programming languages
and hardware.

\style{
.center {
    margin-left: auto;
    margin-right: auto;
}

td ul, td ul>li {
    margin: 0;
}

#lang-comparison td:nth-child(2),
#lang-comparison td:nth-child(3) {
    text-align: center;
}

#hw-comparison td:nth-child(2),
#hw-comparison td:nth-child(3),
#hw-comparison td:nth-child(4) {
    text-align: center;
}

#lang-comparison, #hw-comparison {
    min-width: 75%;
}

.striped tr:nth-child(even) td {
    background-color: var(--deep-background-color);
}
}

\macro[\neg-inf]{\math{\mrow{\mo{\N{MINUS SIGN}}\mi{\N{INFINITY}}}}}
\macro[\pos-inf]{\math{\mrow{\mo{+}\mi{\N{INFINITY}}}}}

\h4[id=language-support]{Language support for integer division}

\table[id=lang-comparison, class = center striped]{
\tr{
    \th{Language} \th{Quotient} \th{Remainder} \th{Rounding}
}
\tr{
    \td{C and C++}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{D}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Objective-C}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{C#}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Java}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Rust}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Go}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Swift}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Scala}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{OCaml}
    \td{\tt{/}}
    \td{\tt{mod}}
    \td{to zero}
}
\tr{
    \td{Perl}
    \td{\tt{int($a/$b)}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{GLSL}
    \td{\tt{/}}
    \td{N/A}
    \td{to zero}
}
\tr{
    \td{JavaScript}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero (for \tt{BigInt} operands)}
}
\tr{
    \td{Python}
    \td{\tt{//}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to \neg-inf}
}
\tr{
    \td{Lua}
    \td{\tt{//}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to \neg-inf}
}
\tr{
    \td{R}
    \td{\tt{\N{PERCENT SIGN}/\N{PERCENT SIGN}}}
    \td{\tt{\N{PERCENT SIGN}\N{PERCENT SIGN}}}
    \td{to \neg-inf}
}
\tr{
    \td{Dart}
    \td{\tt{~/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to \neg-inf}
}
\tr{
    \td{Haskell}
    \td{\tt{quot}, \tt{div}}
    \td{\tt{rem}, \tt{mod}}
    \td{\ul{
        \li{\tt{quot} and \tt{rem} to zero}
        \li{\tt{div} and \tt{mod} to \neg-inf}
    }}
}
\tr{
    \td{Ada}
    \td{\tt{/}}
    \td{\tt{rem}, \tt{mod}}
    \td{\ul{
        \li{\tt{/} and \tt{rem} to zero}
        \li{\tt{mod} to \neg-inf}
    }}
}
\tr{
    \td{Fortran}
    \td{\tt{/}}
    \td{\tt{mod}, \tt{modulo}}
    \td{\ul{
        \li{\tt{/} and \tt{mod} to zero}
        \li{\tt{modulo} to \neg-inf}
    }}
}
\tr{
    \td{CSS}
    \td{N/A}
    \td{\tt{rem()}, \tt{mod()}}
    \td{\ul{
        \li{\tt{rem()} to zero}
        \li{\tt{mod()} to \neg-inf}
    }}
}
\tr{
    \td{Kotlin}
    \td{\tt{/}, \tt{rem()}}
    \td{\tt{\N{PERCENT SIGN}}, \tt{mod()}}
    \td{\ul{
        \li{\tt{/} and \tt{rem()} to zero}
        \li{\tt{mod()} to \neg-inf}
    }}
}
\tr{
    \td{Julia}
    \td{\tt{div(x,y,r)}}
    \td{\tt{rem(x,y,r)}}
    \td{
        depending on \tt{RoundingMode} \tt{r}:\ul{
            \li{to zero (default),}
            \li{away from zero,}
            \li{to \pos-inf or \neg-inf, or}
            \li{to nearest (ties to even)}
        }
    }
}
}

\Bnote{
When a division rounds towards zero,
the remainder has the dividend (left operand) sign.
When a division rounds towards \neg-inf,
the remainder has the divisor (right operand) sign.
}

\h4{Hardware support for integer division}

\table[id=hw-comparison, class = center striped]{
\tr{
    \th{Architecture} \th{Type} \th{Quotient} \th{Remainder} \th{Rounding}
}
\tr{
    \td{x86 and x86_64}
    \td{CPU}
    \td{\tt{idiv}, \tt{div}}
    \td{\tt{idiv}, \tt{div}}
    \td{to zero}
}
\tr{
    \td{ARMv7-A and newer}
    \td{CPU}
    \td{\tt{sdiv}, \tt{udiv}}
    \td{N/A}
    \td{to zero}
}
\tr{
    \td{RISC-V}
    \td{CPU}
    \td{\tt{div}, \tt{divu}}
    \td{\tt{rem}, \tt{remu}}
    \td{to zero}
}
\tr{
    \td{PowerPC}
    \td{CPU}
    \td{\tt{divw}, \tt{divwu}}
    \td{N/A}
    \td{to zero}
}
\tr{
    \td{MIPS}
    \td{CPU}
    \td{\tt{div}, \tt{divu}}
    \td{\tt{div}, \tt{divu},\br\tt{rem}, \tt{remu}}
    \td{to zero}
}
\tr{
    \td{AVR (8-bit), PIC16, etc.}
    \td{CPU}
    \td{N/A}
    \td{N/A}
    \td{N/A}
}
\tr{
    \td{WebAssembly}
    \td{VM}
    \td{\tt{div_s}, \tt{div_u}}
    \td{\tt{rem_s}, \tt{rem_u}}
    \td{to zero}
}
\tr{
    \td{LLVM IR}
    \td{VM}
    \td{\tt{sdiv}, \tt{udiv}}
    \td{\tt{srem}, \tt{urem}}
    \td{to zero}
}
\tr{
    \td{Java Bytecode}
    \td{VM}
    \td{\tt{idiv}}
    \td{\tt{irem}}
    \td{to zero}
}
}

\Bnote{
For unsigned division like \tt{div} on x86,
there is no distinction between rounding to zero and rounding to \neg-inf{},
which is why everything is listed as "to zero" for simplicity.
}

While every architecture rounds to zero,
there there are major differences in how the remainder is obtained:
\ul{
    \li{On x86_64 and MIPS, the quotient and remainder are computed simultaneously,
    although MIPS also supports separate computation of the remainder.}
    \li{On other architectures, even if there is support for computing the remainder separately,
    if both the quotient and remainder are needed,
    it is faster to compute the remainder using the quotient of the division.}
    \li{In some cases, the remainder can \em{only} be computed using the quotient.}
}

\Bnote{
Given two integers \math{\mi{x}} and \math{\mi{y}},
the quotient \math{\mrow{
    \mi{q}
    \mo{=}
    \mo{\N{LEFT FLOOR}}
    \mfrac{\mi{x}\mi{y}}
    \mo{\N{RIGHT FLOOR}}
}} (or rounded otherwise to an integer),
the remainder of the division is equal to
\math{\mrow{
    \mi{x}
    \mo{\N{MINUS SIGN}}
    \mi{y}
    \mo{\N{MULTIPLICATION SIGN}}
    \mi{q}
}}\N{ZERO-WIDTH NO-BREAK SPACE}.

\em{Only} if the division rounds towards zero can this also be translated literally
into a multiplication and subtraction,
without the possibility of overflow.
This makes rounding towards zero \em{by far} the most useful rounding mode in computing,
and it is no coincidence that every architecture implements it.
}

\h2{Motivation}

Rounding modes other than rounding towards zero are commonly useful.
An extremely common alternative is rounding towards \neg-inf,
which is the rounding mode of the division operator in some other languages
(\ref[#language-support]).
See below for some motivating examples.

\Bex{
A common problem is to compute how many chunks/buckets/blocks of a fixed size
are needed to fit a certain amount of elements,
which involves a division which rounds towards \pos-inf{}.
\cppblock{
const int bucket_size = 1000;
int elements = 100;

int buckets_required = elements / bucket_size; // WRONG, zero
int buckets_required = std::div_to_inf(elements, bucket_size); // OK, one bucket
}
}

\Bex{
A common problem is to compute which chunk/bucket/block an element falls into.
This requires division which rounds towards \neg-inf{}.
\cppblock{
const int bucket_size = 1000;
int a = 10;
int b = -10;

int a_bucket = a / bucket_size; // OK, zero
int b_bucket = b / bucket_size; // WRONG, also zero

int a_bucket = std::div_to_neg_inf(a, bucket_size); // OK, zero
int b_bucket = std::div_to_neg_inf(b, bucket_size); // OK, -1
}
Note that with truncating division,
the zero-bucket would contain all elements in [-999, 999],
which would make it larger than any other bucket.
}

While the examples are somewhat abstract,
they appear in vast amounts of concrete problems.
For example, we need to know how many blocks of memory must be allocated
to hold a certain amount of bytes,
do interval arithmetic,
fixed-point arithmetic with rounding of choice, etc. etc.

\h3[id=trivial-for-user]{Is this not trivial for the user to do?}

At first glance,
it would seem trivial to change rounding modes by making slight adjustments to \tcode{/}.
However, doing so with correct output, high performance,
and without introducing more undefined behavior than \tcode{x / y} already has,
is surprisingly hard.

There is an \em{ocean} of examples where C and C++ users have gotten this wrong.
A few droplets are listed below.

\Bug{
At the time of writing,
the \em{first} Google search result for "c++ ceiling integer division"
yields \ref[StackOverflowCeil].
Almost every answer does not permit signed integers,
gives wrong results,
or has undefined behavior for certain inputs
(not counting division by zero or \tcode{\hl[macro]{INT_MIN} / -1}).

For example, one answer with 67 upvotes (at the time of writing)
attempts to implement ceiling (rounded towards \pos-inf)
integer division as follows:
\cppblock{
q = (x % y) ? x / y + 1 : x / y;
}
The quotient \tcode{q} would be \tcode{1}, not \tcode{0}
for inputs \tcode{x = -1} and \tcode{y = 2},
which is obviously wrong because it rounds \tcode{-0.5} up to \tcode{1}, skipping zero.

To be fair, the answer is correct for positive integers,
and perhaps the author didn't want to support negative inputs anyway.
However, the answer contains no disclaimer that clarifies this.
}

\Bug{
In the question "Rounding integer division (instead of truncating)" for C
(\ref[StackOverflowRound]),
OP expresses that they want to divide with rounding to the nearest integer,
rather than rounding towards zero.

While the top 11 answers are highly decorated with upvotes,
they all overflow for large inputs,
use \tcode{float} (which has accuracy issues),
have the wrong rounding mode,
or are plain incorrect.

The first correct solution can only be found at 5 upvotes, by user A Fog:
\cppblock{
unsigned int rounded_division(unsigned int n, unsigned int d) {
    unsigned int q = n / d;  // quotient
    unsigned int r = n % d;  // remainder
    if (r > d>>1  // fraction > 0.5
    || (r == d>>1 && (q&1) && !(d&1))) { // fraction == 0.5 and odd
        q++;
    }
    return q;
}
}
Unfortunately, this solution does not support negative inputs,
and is somewhat branch-heavy.
When compiled with Clang,
a possible path of execution would go through four conditional jumps
depending on \tcode{(r > d>>1)}, \tcode{(r == d>>1)}, \tcode{(q&1)}, and \tcode{!(d&1)},
where all but \tcode{(r == d>>1)} are extremely unpredictable (basically coin flips).
See \ref[https://godbolt.org/z/ax6hr1r53].
}

\Bug{
These division functions taken from \ref[BuggyDivisions] have several problems:
\cppblock{
static int div_floor(int a, int b) {
    return (a ^ b) < 0 && a ? (1 - abs(a)) / abs(b) - 1 : a / b;
}

static int div_round(int a, int b) {
    return (a ^ b) < 0 ? (a - b / 2) / b : (a + b / 2) / b;
}

static int div_ceil(int a, int b) {
    return (a ^ b) < 0 || !a ? a / b : (abs(a) - 1) / abs(b) + 1;
}
}
\ul{
\li{\tcode{abs(a)} and \tcode{abs(b)} have undefined behavior given \tcode{\hl[macro]{INT_MIN}} input}
\li{\tcode{div_round} overflows on large inputs in \tcode{a - b} and \tcode{a + b}}
\li{
all functions branch depending on whether the quotient is negative,
which may be highly unpredictable
}
}
}

\Bnote{See \ref[#implementation] for proper implementations.}

Users sometimes also implement these functions using \tcode{std::floor} or \tcode{std::ceil},
but this can equally yield incorrect results,
and use of floating-point numbers is unnecessary for this task.

\h3[id=computing-remainders-is-hard]{Computing remainders is hard, actually}

There exist various use cases (modular arithmetic, integer-to-string conversion, etc.)
where we need both the quotient and remainder at the same time.
The naive approach to computing the remainder
using an integer division function \placeholder{divide} looks something like:

\cppblock{
int x = /* ... */, y = /* ... */;
int quotient = \exposid{divide}(x, y);
int remainder = x - quotient * y;
}

This approach is only safe when \tcode{\exposid{divide}(x,y)} is \tcode{x/y},
i.e. when rounding towards zero.

\Bug{
The following function, which yields the quotient rounded towards \pos-inf,
as well as the remainder,
is not safe for large inputs:
\cppblock{
std::div_t div_rem_ceil(int x, int y) {
    bool quotient_positive = (x < 0) == (y < 0);
    bool has_remainder = x \N{PERCENT SIGN} y != 0;
    int quotient = x / y + int(quotient_positive && has_remainder);
    int remainder = x - y * quotient;
    return { quotient, remainder };
}
}
If we now call \tcode{div_rem_ceil(\hl[macro]{INT_MAX}, 2)},
where \tcode{\hl[macro]{INT_MAX}} is \tcode{2'147'483'647},
then \tcode{quotient} is \tcode{1'073'741'824}.
The multiplication \tcode{y * quotient} has undefined behavior
because it results in \tcode{2'147'483'648}, which cannot be represented as \tcode{int}.

Crucially, it does not mean that \tcode{div_rem_ceil} cannot be defined for these inputs.
The correct quotient is \tcode{1'073'741'824},
and the correct remainder is \tcode{-1}.
It just means that for any rounding mode except towards zero,
we cannot use the naive formula to obtain a remainder.
}

In conclusion,
the proposal should also include a way to obtain a remainder in tandem with the quotient.
Any other design would simply invite bugs where users foolishly assume that
the \tcode{x - quotient * y} method works for all rounding modes.

\h2{Design}

The design aims of this proposal are to provide \em{concise},
\em{simple}, \em{efficient}, \em{robust} functions
which are useful \em{in practice}.

\Bimp{
As a rule of thumb, the proposed functionality should be a drop-in replacement
for the various bad implementations that users have written themselves (\ref[#trivial-for-user]),
and it should take the underlying implementation (\ref[#implementation]) into consideration.
This rule of thumb influences \em{every} design choice.
}

\Bnote{
You may find a complete list of functions in
\ref[#try-it-yourself],
\ref[#wording], and
\ref[#implementation].
}

\h3{Relation to P0105R1}

The design somewhat leans on \ref[P0105R1]
(which first proposed division functions with custom rounding),
but heavily deviates from it.
In general, \ref[P0105R1] was a proposal with overly broad scope,
and some questionable design choices, such as:

\ul{
\li{Making some of the rounding modes conditionally supported,
even when providing them isn't particularly difficult.}
\li{Adding rounding modes which optimize for latency or code size,
without much motivation or details.
The proposal provided no concrete example of how this implementation freedom could be utilized,
and I suspect that any implementation would default to rounding to zero,
matching the \tcode{/} operator anyway.}
}

\h3{Naming}

All functions which compute a quotient begin with \tcode{div},
and functions which also compute a remainder begin with \tcode{div_rem}.
Furthermore, the functions include the name of the rounding mode
in a format that requires as little prior knowledge as feasible.

\h4{Isn't \tcode{std::div_*} inconsistent with the existing \tcode{std::div}?}

It is worth pointing out that there already exist \tcode{std::div}
functions in the standard library, returning \tcode{std::div_t},
which contains the quotient and remainder.
The proposal does not aim for consistency because the facilities are an unnecessary
and rarely-used C relic for the most part.

On the contrary, when investigating existing practice in \ref[#trivial-for-user],
I found that almost every definition of these differently-rounded division functions
uses \tcode{div_*} names.
This naming scheme is \em{well-established} and \em{intuitive} for users.

\h4{Should it be \tcode{std::div_floor} and \tcode{std::div_ceil}?}

While the use of names like \tcode{floor} and \tcode{ceil} is common in various domains,
including in \header{cmath},
I do not believe we should perpetuate this design because:

\ul{
\li{
The scheme does not nicely extend to division with rounding away from zero;
there is no established term for that.
}
\li{
A hypothetical \tcode{std::div_round} (for rounding to the nearest integer)
would be somewhat perplexing because \em{all} proposed functions round,
just towards different targets.
}
\li{
The scheme is needlessly hostile towards novices
who are not yet familiar with the fact that \math{\mrow{\mi{floor}\mo{(}\mi{x}\mo{)}}}
rounds towards \neg-inf{}.
By comparison, \tcode{std::div_to_neg_inf} is self-documenting.
}
}

Regardless whether the functions end up called \tcode{std::div_floor}
or \tcode{std::div_to_neg_inf}, the names should remain somewhat brief so they take up
a reasonable amount of space in C++ expressions.

\h4{Should it be \tcode{std::div_to_pos_inf}?}

While it looks nicer on paper if \tcode{std::div_to_pos_inf}
and \tcode{std::div_to_neg_inf} have symmetrical names,
this does not have any clear technical benefit to the user.
\tcode{std::div_to_inf} is sufficiently clear,
and adding \tcode{pos} would merely make the function name longer.

\h4[id=naming-mod]{Why is it \tcode{std::mod}?}

\Bnote{
See \ref[#mod].
}

Despite the fact that \tt{mod} is somewhat of a misnomer
("remainder" and "modulo" are synonyms),
and despite that it is inconsistent with \tcode{std::div_rem},
it is arguably the best name because:

\ul{
\li{
It follows the conventions of Haskell, Ada, CSS, and many more languages,
where \tt{mod} rounds towards \neg-inf (unlike \tt{\N{PERCENT SIGN}}, \tt{rem}, etc.).
See \ref[#language-support].
}
\li{
It matches the notation of the modulo operator in mathematical literature.
That is,
\math{\mrow{
    \mo{\N{MINUS SIGN}}
    \mn{2}
    \mo{mod}
    \mn{5}
    \mo{=}
    \mn{3}
}}\N{ZERO-WIDTH NO-BREAK SPACE}.
}
}

\h3{Interface}

The functions generally match the style of similar features in \header{numeric},
like \eelis{numeric.sat} or \eelis{numeric.ops.gcd}.
The design also follows \ref[P3161R4].

\Bex{
For rounding to zero, the following functions exist:
\cppblock{
template<class T>
struct div_result {
    T quotient;
    T remainder;
    friend auto operator<=>(const div_result&, const div_result&) = default;
};

template<class T>
  constexpr div_result<T> div_rem_to_zero(T x, T y) /* not noexcept */;
template<class T>
  constexpr T div_to_zero(T x, T y) /* not noexcept */;
}
It is constrained to accept only signed or unsigned integer types.
}

\h4[id=error-handling-noexcept]{Error handling and \tcode{noexcept}}

These functions are not \tcode{noexcept} because they could not have a wide contract;
they naturally have undefined behavior for cases like \tcode{div_to_zero(x, 0)}
or \tcode{div_to_zero(\hl[macro]{INT_MIN}, -1)}.
Looking at \ref[#implementation],
it would require additional effort to perform error handling such as throwing exceptions,
so it seems best to leave these functions undefined if and only if division is undefined too.

However, an invocation of these functions is not a constant expression for such inputs;
i.e. we don't get undefined behavior during constant evaluation.
This can even be implemented without a single additional line of code:
since we always perform a division in these functions,
they naturally get disqualified from being core constant expressions when division is undefiend.

\h4{Why no \tcode{std::rounding} parameter?}

As compared to \ref[P0105R1],
I do not propose that the rounding mode is passed as a runtime parameter.

In virtually every case, the rounding mode for an integer division is a fixed choice.
This is evidenced by the ten trillion existing uses of the \tcode{/} operator
which \em{always} truncate.
Also, the implementation of the proposed functions does not lend itself to a runtime parameter:

\cppblock{
int div_to_zero(int x, int y) {
    return x / y;
}

int div_to_neg_inf(int x, int y) {
    bool quotient_negative = (x ^ y) < 0;
    return (x / y) - int(x % y != 0 && quotient_negative);
}

int div_away_zero(int x, int y) {
    constexpr auto sgn = [](int z) { return z < 0 ? -1 : 1; };
    int quotient_sign = sgn(x) * sgn(y);
    return (x / y) + int(x % y != 0) * quotient_sign;
}
}
As can be seen, these implementations are substantially different.

\Bnote{
While \tcode{div_to_neg_inf} could \em{theoretically} use the \tcode{quotient_sign} instead,
it requires more operations to compute this positive/negative sign instead of merely checking
whether the quotient is negative.
This would be an unnecessary performance penalty.

In practice, compilers optimize \tcode{sgn(x) * sgn(y) < 0}
strictly worse than \tcode{(x ^ y) < 0}.
}

If we now provided a runtime \tcode{std::rounding},
the obvious implementation would look like:

\cppblock{
enum struct rounding { to_zero, to_neg_inf, away_zero, /* ... */ };

int divide(int x, int y, rounding_mode mode) {
    switch (mode) {
    case rounding::to_zero: return __div_to_zero(x);
    case rounding::to_neg_inf: return __div_to_neg_inf(x);
    case rounding::away_zero:  return __div_away_zero(x);
    // ...
    }
    std::unreachable();
}
}

The user can trivially make such an \tcode{enum class} and \tcode{switch} themselves,
if they actually need to.
If they don't (which is likely),
all we accomplish is making the user write
\tcode{std::divide(std::rounding::to_neg_inf, x, y)} instead of
\tcode{std::div_to_neg_inf(x, y)}.

\h4[id=div-result]{\tcode{std::div_result<T>}}

As seen in in \ref[#interface],
we define an additional class template \tcode{std::div_result}:

\cppblock{
template<class T>
struct div_result {
    T quotient;
    T remainder;
    friend auto operator<=>(const div_result&, const div_result&) = default;
};
}

This generally matches standard library style,
including the active proposal \ref[P3161R4],
and including the "legacy types" \tcode{std::div_t},
\tcode{std::ldiv_t}.
That is, we should not use reference output parameters,
but return a value.

However, we should also not reuse those legacy types
because it is not possible to deduce their "member type" from the class,
which would make them clunky in generic code.
There also exist no such classes for extended integer types and bit-precise integer types.

\tcode{operator<=>} exists because the user may want to compare
the quotient and remainder to an existing pair of values in one go,
or store results of \tcode{std::div_rem} functions in a \tcode{std::set}, etc.
It would seem arbitrarily limiting to make \tcode{std::div_result} incomparable.

\h4[id=div-rem-combined]{Do we really need the \tcode{std::div_rem_*} functions?}

Yes, because it is non-trivial to compute the remainder without overflow
for rounding modes other than towards zero.
See \ref[#computing-remainders-is-hard].

Furthermore,
it is relatively cheap to obtain the remainder as a side product of any division function
(see \ref[#implementation]).
On extremely feature-starved hardware with no instructions for division and multiplication,
computing the remainder via multiplication may be more expensive
than producing it "directly" during division (implemented in software).

\h3{Supported rounding modes}

It is apparent that the proposal contains quite a lot of rounding modes
\N{EN DASH} more than just the traditional \tcode{ceil}, \tcode{floor}, \tcode{round}.
It is therefore valid to ask:

\blockquote{Do we really need all these rounding modes?}

All proposed "top-level rounding modes" have practical applications.
For consistency, the same set of "tie-breaking rounding modes" is provided.
In any case, the implementation of these modes is all fairly similar,
and there is neither any significant implementation cost (\ref[#implementation])
nor wording cost (\ref[#wording])
to having a few extra functions.
This would be a much different discussion for floating-point numbers.

I suspect that cherry-picking the "useful" rounding modes out of the proposed ones
would devolve into endless discussion,
and the design would have an inconsistent feel to it if say,
division away from zero was provided,
but no division to the nearest integer with tie breaks away from zero.

\h4{Rounding to zero}

The "trivial" functions \tcode{std::div_to_zero}
and \tcode{std::rem_dividend_sign} exist solely for consistency and enhanced expressiveness.
Note that not every has a truncating integer division like C++.
For example, the \tt{\hl[sym-op]{//}} operator in Python rounds towards \neg-inf{}.
A team of developers with primarily Python experience/habits
may thus benefit from always expressing
rounding mode explicitly with \tcode{std::div_to_zero} to avoid confusion.

\h4{Rounding to even/odd}

Rounding to even/odd integers is mainly useful because it is unbiased.
That is, when dividing a large amount of integers,
results would not gravitate towards one end due to rounding mode bias towards zero, \pos-inf, etc.
This may be important when operating on fixed-point numbers.

\ref[P0105R1] provides additional motivation and explanation of these rounding modes.

\h4{To-nearest-rounding division and tie breaking}

Saying "round to nearest" is not clear enough in itself
because ties (where the fractional part of the quotient is exactly \tcode{.5})
could also be resolved in multiple ways.
Any of the "top-level rounding modes" could plausibly be chosen
as a "tie-breaking rounding mode" as well,
which is what this proposal offers.

\h3[id=mod]{\tcode{std::mod}}

In addition to the quotient (\tcode{std::div_*})
and quotient/remainder functions (\tcode{std::div_rem_*}),
we also define a single function \tcode{std::mod}
which specifically computes the remainder of the division rounding towards \neg-inf{}.

Unlike the other rounding modes,
the remainder of division rounding to \neg-inf is uniquely useful for modular arithmetic
because the sign of the remainder is the sign of the divisor.
In other words, if we divide by a positive number, the remainder is always positive.
This is why it has a dedicated function.

Division rounding to zero, where the sign of the remainder is that of the divisor,
already has \tcode{\N{PERCENT SIGN}}, so no dedicated function is required.
The other rounding modes have more chaotic remainder signs,
and thus it is rarely useful to compute the remainder in isolation,
not in conjunction with the quotient.

\Bnote{See \ref[#naming-mod].}

\h2{Implementation experience}

A reference implementation can be found on \ref[GitHub].
A simplified version of that, for educational purposes,
can be found at \ref[#implementation].

Generally speaking,
a portable strategy is to implement all divisions by performing a division
with rounding towards zero (\tcode{/} and \tcode{\N{PERCENT SIGN}}),
and then adjusting the quotient and remainder to emulate a different rounding mode.

\Bex{
Just to illustrate the principle,
consider how one would round towards \pos-inf with unsigned operands:
\cppblock{
unsigned div_to_zero(unsigned x, unsigned y) { // for reference
    return x / y;
}
unsigned div_to_inf(unsigned x, unsigned y) {
    return x / y + (x \N{PERCENT SIGN} y != 0); // + 1 if the remainder is nonzero
}
}
On x86_64, Clang compiles this as follows:
\codeblock[asm]{
div_to_zero:               ; edi = x, esi = y
        mov     eax, edi   ; eax = edi
        xor     edx, edx   ; edx = 0 (clear upper 32 bits of divided)
        div     esi        ; eax = eax / esi, edx = eax % esi
        ret                ; return eax

div_to_inf:                ; edi = x, esi = y
        mov     eax, edi   ; eax = edi
        xor     edx, edx   ; edx = 0 (clear upper 32 bits of divided)
        div     esi        ; eax = eax / esi, edx = eax % esi
        cmp     edx, 1     ; b = edx < 1
        sbb     eax, -1    ; eax -= -1 + b
        ret                ; return eax
}
Note that even on architectures where the remainder is not computed
simultaneously with the quotient like for \code[asm]{div},
only one division is necessary;
the remainder can be obtained from the quotient.
}

Consequently, the implementation effort for all of these functions is close to zero.
None of them require intrinsics or much architecture-specific knowledge;
if any, rounding towards zero is supported in hardware
(\ref[#hardware-support-for-integer-division]),
and even if it isn't,
\tcode{/} has to exist and the other rounding modes can be implemented in terms of it,
exactly the same.

\h2{Try it yourself}

\style{
.int-input {
    background: none;
    border: 1px solid var(--border-color);
    font-family: var(--monospace-family);
    text-align: right;
    width: fit-content;
    min-width: 2em;
    color: inherit;
}
}

If you have JavaScript enabled,
you can play around with the following code block.
\cppblock{
int x = \html-input[id=x-input,class=int-input,type=number,value=-12];
int y = \html-input[id=y-input,class=int-input,type=number,value=5];

// input expression             \N{RIGHTWARDS ARROW}  output
double(x) / double(y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-double]{-2.4}}

std::div_to_zero(x, y)          \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-trunc]{-2}} // x / y
std::div_away_zero(x, y)        \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-mag]{-3}}
std::div_to_inf(x, y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ceil]{-2}}
std::div_to_neg_inf(x, y)       \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-floor]{-3}}
std::div_to_odd(x, y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-odd]{-3}}
std::div_to_even(x, y)          \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-even]{-2}}

std::div_ties_to_zero(x, y)     \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-trunc]{-2}}
std::div_ties_away_zero(x, y)   \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-mag]{-2}}
std::div_ties_to_inf(x, y)      \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-ceil]{-2}}
std::div_ties_to_neg_inf(x, y)  \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-floor]{-2}}
std::div_ties_to_odd(x, y)      \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-odd]{-2}}
std::div_ties_to_even(x, y)     \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-even]{-2}}

x \N{PERCENT SIGN} y                           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=rem-trunc]{-2}} // sign matches x
std::mod(x, y)                  \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=rem-floor]{3}} // sign matches y
}

\Bnote{
This demonstration conveniently ignores that \tcode{int} has finite size.
Under the hood, calculations are performed using JavaScript's \tt{BigInt}.
}

\script{\include{intdiv.js}}

\h2{Wording}

All changes are relative to \ref[N5008].

\h3{[structure.specifications]}

In \eelis{structure.specifications#3},
add a bullet immediately following bullet 3.4:

\macro[\constexpects]{\Fundesc{Constant-checked preconditions}}

\Bdiff{
\ul{
\li{
\expects
conditions that the function assumes to hold whenever it is called;
violation of any preconditions results in undefined behavior.
}
\li{\hardexpects [\N{HORIZONTAL ELLIPSIS}]}
\li{\ins{
\constexpects
equivalent to a \Fundescx{Preconditions} specification,
except that a function call expression that violates the assumed condition
is not a core constant expression\iref{expr.const}.
}}
}
}

Change \eelis{structure.specifications#4} as follows:

\Bdiff{
Whenever the \Fundescx{Effects} element specifies that the semantics of some function
\tcode{F} are \term{Equivalent to} some code sequence, then the various elements are
interpreted as follows.
If \tcode{F}'s semantics specifies any \Fundescx{Constraints} or \Fundescx{Mandates} elements,
then those requirements are logically imposed prior to the \term{equivalent-to} semantics.
Next, the semantics of the code sequence are determined by the
\Fundescx{Constraints},
\Fundescx{Mandates},
\Fundescx{Preconditions},
\Fundescx{Hardened preconditions},
\ins{\Fundescx{Constant-checked preconditions},}
\Fundescx{Effects},
\Fundescx{Synchronization},
\Fundescx{Postconditions},
\Fundescx{Returns},
\Fundescx{Throws},
\Fundescx{Complexity},
\Fundescx{Remarks}, and
\Fundescx{Error conditions}
specified for the function invocations contained in the code sequence.
The value returned from \tcode{F} is specified by \tcode{F}'s \Fundescx{Returns} element,
or if \tcode{F} has no \Fundescx{Returns} element,
a non-\tcode{void} return from \tcode{F} is specified by the
\tcode{return} statements\iref{stmt.return} in the code sequence.
If \tcode{F}'s semantics contains a \Fundescx{Throws},
\Fundescx{Postconditions}, or \Fundescx{Complexity} element,
then that supersedes any occurrences of that element in the code sequence.
}

\h3{[version.syn]}

Change the synopsis in \eelis{version.syn} as follows:

\Bdiff{
\itemdecl{
#define __cpp_lib_integer_comparison_functions      202002L // \serif{also in }<utility>
\ins{#define __cpp_lib_integer_division                  20XXXXL // \serif{freestanding, also in }<numeric>}
#define __cpp_lib_integer_sequence                  201304L // \serif{freestanding, also in }<utility>
}
}

\h3{[bit.pow.two]}

Change \eelis{bit.pow.two#5} as follows:

\Bdiff{
\del{\expects} \ins{\constexpects}
\math{\mi{N}} is representable as a value of type \tcode{T}.
}

Delete \eelis{bit.pow.two#8}:

\Bdel{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.
}

\h3{[numeric.ops.overview]}

Change the synopsis in \eelis{numeric.ops.overview} as follows:

\Bdiff{
\itemdecl{
namespace std {
  \html{[\N{HORIZONTAL ELLIPSIS}]}

  // \serif{[numeric.sat], saturation arithmetic}
  template<class T>
    constexpr T add_sat(T x, T y) noexcept;
  template<class T>
    constexpr T sub_sat(T x, T y) noexcept;
  template<class T>
    constexpr T mul_sat(T x, T y) noexcept;
  template<class T>
    constexpr T div_sat(T x, T y) noexcept;
  template<class T, class U>
    constexpr T saturate_cast(U x) noexcept;

\ins{  // \serif{[numeric.int.div], integer division}
  template<class T>
  struct div_result {
    T quotient;
    T remainder;
    friend auto operator<=>(const div_result&, const div_result&) = default;
  };

  template<class T>
    constexpr T div_to_zero(T x, T y);
  template<class T>
    constexpr T div_away_zero(T x, T y);
  template<class T>
    constexpr T div_to_inf(T x, T y);
  template<class T>
    constexpr T div_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_to_odd(T x, T y);
  template<class T>
    constexpr T div_to_even(T x, T y);
  template<class T>
    constexpr T div_ties_to_zero(T x, T y);
  template<class T>
    constexpr T div_ties_away_zero(T x, T y);
  template<class T>
    constexpr T div_ties_to_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_odd(T x, T y);
  template<class T>
    constexpr T div_ties_to_even(T x, T y);

  template<class T>
    constexpr div_result<T> div_rem_to_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_away_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_neg_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_odd(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_even(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_away_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_odd(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_even(T x, T y);

  template<class T>
    constexpr T mod(T x, T y);}
}
}
}

\h3{[numeric.sat.func]}

Change \eelis{numeric.sat.func#9} as follows:

\Bdiff{
\del{\expects} \ins{\constexpects}
\tcode{y != 0} is \tcode{true}.
}

Delete \eelis{numeric.sat.func#11}:

\Bdel{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.   
}

\h3[id=new-subclause]{[numeric.int.div]}

Append a new subclause to \eelis{numeric.ops},
following \eelis{numeric.sat}:

\Bins{
\html-h2{Integer division \stable-ref{numeric.int.div}}
\Vset[pnum]{0}

\macro[\div-returns{rounding}]{\returns \math{\mfrac{\mi{x}\mi{y}}}, rounded \put{}.}
\macro[\div-returns-nearest{rounding}]{
\returns \math{\mfrac{\mi{x}\mi{y}}}, rounded towards the nearest integer.
If two integers are equidistant, the result is \put{}.
}
\macro[\div-constraints]{\constraints
\tcode{T} is a signed or unsigned integer type\iref{basic.fundamental}.}

\itemdecl{
template<class T>
  constexpr T div_to_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards zero}\br
\wg21-note{
The result equals \tcode{x / y}.
}
}

\itemdecl{
template<class T>
  constexpr T div_away_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{away from zero}
}

\itemdecl{
template<class T>
  constexpr T div_to_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards positive infinity}
}

\itemdecl{
template<class T>
  constexpr T div_neg_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards negative infinity}
}

\itemdecl{
template<class T>
  constexpr T div_to_odd(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards the nearest odd integer}
}

\itemdecl{
template<class T>
  constexpr T div_to_even(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards the nearest even integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the integer with lower magnitude}
}

\itemdecl{
template<class T>
  constexpr T div_ties_away_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the integer with greater magnitude}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the greater integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_neg_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the lower integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_odd(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the odd integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_even(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the even integer}
}

\itemdecl{
template<class T>
  constexpr div_result<T> div_rem_\exposid{rounding}(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\returns
A result object where
\ul[style=margin:0]{
\li{\tcode{quotient} is the quotient \math{\mi{q}} returned by \tcode{div_\exposid{rounding}(x, y)} and}
\li{
\tcode{remainder} is \math{\mrow{\mi{x}\mo{\N{MINUS SIGN}}\mi{q}\mi{y}}}
if \tcode{T} is signed, otherwise
the integer congruent to \math{\mrow{\mi{x}\mo{\N{MINUS SIGN}}\mi{q}\mi{y}}}
modulo \math{\msup{\mn{2}\mi{N}}}
where \math{\mi{N}} is the width of \tcode{T}.
}
}
\wg21-note{
It is possible for \tcode{div_\exposid{rounding}(x, y)} to have well-defined behavior even when
\tcode{x - quotient * y} has undefined behavior.
\br\wg21-example{
Assume that \tcode{\hl[macro]{INT_MAX}} equals \tcode{2'147'483'647}.
\itemdecl{
const auto q_to_zero = \hl[macro]{INT_MAX} / 2;              // \serif{\tcode{q_to_zero} is \tcode{1'073'741'823}.}
const auto [q, r] = div_rem_to_inf(\hl[macro]{INT_MAX}, 2);  // \serif{\tcode{q} is \tcode{1'073'741'824} and \tcode{r} is \tcode{-1}.}
int r2 = x - q * 2;                              // \serif{This multiplication has undefined behavior.}
}
}}
}

\itemdecl{
template<class T>
  constexpr T mod(T x, T y);
}

\itemdescr{
\pnum
\effects
Equivalent to \tcode{div_rem_to_neg_inf(x, y).remainder}.
\br\wg21-note{
The result is negative if and only if \tcode{y} is negative and \tcode{x} is nonzero.
}
}

}

\Bwarn{
If the mathematical notation in the block above does not render for you,
you are using an old browser with no MathML support.
Please open the document in a recent version of Firefox or Chrome.
}

\h3{[simd.bit]}

Change \eelis{simd.bit#4} as follows:

\Bdiff{
\del{\expects} \ins{\constexpects}
For every \math{\mi{i}} [\N{HORIZONTAL ELLIPSIS}].
}

Delete \eelis{simd.bit#6}:

\Bdel{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.   
}

\h2{Acknowledgements}

I sincerely thank Lawrence Crowl (the author of the predecessor paper \ref[P0105R1])
for reviewing this paper in great detail,
providing detailed feedback.
The choice to include combined quotient/remainder functions was only made
after his feedback.

\h2{References}

\bib[
    id = N5008,
    title = Working Draft\, Programming Languages â€” C++,
    date = 2025-03-15,
    author = Thomas KÃ¶ppe,
    link = https://wg21.link/n5008,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf
]
\bib[
    id = P0105R1,
    title = Rounding and Overflow in C++,
    date = 2017-02-05,
    author = Lawrence Crowl,
    link = https://wg21.link/p0105r1,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0105r1.html
]
\bib[
    id = P1889R1,
    title = C++ Numerics Work In Progress,
    date = 2019-12-27,
    author = Alexander Zaitsev,
    link = https://wg21.link/p1889r1,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1889r1.pdf
]
\bib[
    id = P3161R4,
    title = Unified integer overflow arithmetic,
    date = 2025-03-26,
    author = Tiago Freire,
    link = https://wg21.link/p3161r4,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3161r4.html
]
\bib[
    id = StackOverflowCeil,
    title = Fast ceiling of an integer division in C / C++,
    link = https://stackoverflow.com/q/2745074/5740428
]
\bib[
    id = StackOverflowRound,
    title = Rounding integer division (instead of truncating),
    link = https://stackoverflow.com/q/2422712/5740428
]
\bib[
    id = BuggyDivisions,
    author = njohnny84,
    title = Rounding Modes For Integer Division,
    link = https://blog.demofox.org/2022/07/21/rounding-modes-for-integer-division/
]
\bib[
    id = GitHub,
    author = Jan Schultke,
    title = integer-division GitHub repository,
    link = https://github.com/Eisenwave/integer-division
]

\make-bib

\h2[id=implementation,show-number=no]{Appendix A \N{EM DASH} Reference implementation}

See below a simplified implementation for educational purposes,
which works exclusively with \tcode{int}.
See \ref[GitHub] for the full implementation.

\cppblock{\include{intdiv.cpp}}

\Bnote{
Since integer division occurs unconditionally in these functions,
they also trivially satisfy the \ref[#wording] requirement that invocations of these functions
are not constant expressions when the result is not representable.
}

\comment{https://godbolt.org/z/71sffK8ob}
