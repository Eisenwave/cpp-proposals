\import{libwg21.cow}

\wg21-head[
    title = Integer division
]{
\dl{
    \dt{Document number:} \dd{\docnum{D3724R0}}
    \dt{Date:}            \dd{\tt{2025-05-29}}
    \dt{Audience:}        \dd{LEWG, SG6}
    \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21}
    \dt{Reply-To:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
    \dt{GitHub Issue:}    \dd{\ref[https://wg21.link/P3724/github]}
    \dt{Source:}          \dd{\ref[https://github.com/Eisenwave/cpp-proposals/blob/master/src/intdiv.cow]}
}
\hr
}

\abstract{
C++ currently only offers truncating integer division in the form of the \tcode{/} operator.
I propose standard library functions for computing quotients and remainders
with other rounding modes.
}

\h2[listed=no]{Contents}

\make-contents

\h2{Introduction}

C++ currently only offers truncating integer division in the form of the \tcode{/} operator.
However, other rounding modes have various use cases too,
and implementing these as the user can be surprisingly hard,
especially when integer overflow needs to be avoided,
and negative inputs are accepted.

Furthermore, since the \tcode{/} operator is truncating,
the \tcode{\N{PERCENT SIGN}} (remainder) operator may yield negative results
(specifically, when the dividend is negative).
In modular arithmetic, this is typically undesirable.

Therefore, I propose a set of standard library functions
which implement a variety of rounding modes when computing quotients and remainders.
Such a feature was previously part of \ref[P0105R1] and the Numerics TS \ref[P1889R1],
but was eventually abandoned.

\h2{Motivation}

Rounding modes other than truncation (rounding towards zero) are commonly useful.

\example{
A common problem is to compute how many chunks/buckets/blocks of a fixed size
are needed to fit a certain amount of elements,
which involves a division which rounds towards positive infinity.
\cppblock{
const int bucket_size = 1000;
int elements = 100;

int buckets_required = elements / bucket_size; // WRONG, zero
int buckets_required = std::div_to_inf(elements, bucket_size); // OK, one bucket
}
}

\example{
A common problem is to compute which chunk/bucket/block an element falls into.
This requires division which rounds towards negative infinity.
\cppblock{
const int bucket_size = 1000;
int a = 10;
int b = -10;

int a_bucket = a / bucket_size; // OK, zero
int b_bucket = b / bucket_size; // WRONG, also zero

int a_bucket = std::div_to_neg_inf(a, bucket_size); // OK, zero
int b_bucket = std::div_to_neg_inf(b, bucket_size); // OK, -1
}
Note that with truncating division,
the zero-bucket would contain all elements in [-999, 999],
which would make it larger than any other bucket.
}

While the examples are somewhat abstract,
they appear in vast amounts of concrete problems.
For example, we need to know how many blocks of memory must be allocated
to hold a certain amount of bytes.

\h3[id=trivial-for-user]{Is this not trivial for the user to do?}

At first glance,
it would seem trivial to change rounding modes by making slight adjustments to \tcode{/}.
However, doing so with correct output, high performance,
and without introducing more undefined behavior than \tcode{x / y} already has,
is surprisingly hard.

There is an \em{ocean} of examples where C++ users have gotten this wrong.
A few droplets are listed below.

\bug{
At the time of writing,
the \em{first} Google search result for "c++ ceiling integer division"
yields \ref[StackOverflowDivision].
Almost every answer does not permit signed integers,
gives wrong results,
or has undefined behavior for certain inputs
(not counting division by zero or \tcode{INT_MIN / -1}).

For example, one answer with 67 upvotes (at the time of writing)
attempts to implement ceiling (rounded towards positive infinity)
integer division as follows:
\cppblock{
q = (x % y) ? x / y + 1 : x / y;
}
The quotient \tcode{q} would be \tcode{1}, not \tcode{0}
for inputs \tcode{x = -1} and \tcode{y = 2},
which is obviously wrong because it rounds \tcode{-0.5} up to \tcode{1}, skipping zero.

To be fair, the answer is correct for positive integers,
and perhaps the author didn't want to support negative inputs anyway.
However, the answer contains no disclaimer that clarifies this.
}

\bug{
These division functions taken from \ref[BuggyDivisions] have several problems:
\cppblock{
static int div_floor(int a, int b) {
    return (a ^ b) < 0 && a ? (1 - abs(a)) / abs(b) - 1 : a / b;
}

static int div_round(int a, int b) {
    return (a ^ b) < 0 ? (a - b / 2) / b : (a + b / 2) / b;
}

static int div_ceil(int a, int b) {
    return (a ^ b) < 0 || !a ? a / b : (abs(a) - 1) / abs(b) + 1;
}
}
\ul{
\li{\tcode{abs(a)} and \tcode{abs(b)} have undefined behavior given \tcode{INT_MIN} input}
\li{\tcode{div_round} overflows on large inputs in \tcode{a - b} and \tcode{a + b}}
\li{
all functions branch depending on whether the quotient is negative,
and at least for a standard library (which has to cover a wide variety of use cases),
such a branch could be \em{highly} unpredictable
}
}
}

\note{See \ref[#implementation] for proper implementations.}

Users sometimes also implement these functions using \tcode{std::floor} or \tcode{std::ceil},
but this can equally yield incorrect results,
and use of floating-point numbers is unnecessary for this task.

\h2{Design}

The design aims of this proposal are to provide \em{concise},
\em{simple}, \em{efficient}, \em{robust} functions
which are useful \em{in practice}.
You may find a complete list in
\ref[#try-it-yourself],
\ref[#wording], and
\ref[#implementation].

The design somewhat leans on \ref[P0105R1]
(which first proposed division functions with custom rounding),
but heavily deviates from it.
In general, \ref[P0105R1] was a proposal with overly wide scope,
large amounts of unmotivated features (which the author even points out himself),
and zero implementation experience (at least none provided in the paper).

To name one of many problems, the proposal suggested to include
\tcode{fastest}, \tcode{smallest}, and \tcode{unspecified}
rounding modes.
However, it provided no concrete examples of how implementations would leverage
these optimization opportunities,
or what the measurable performance impact would be.
In practice, integer division is a fairly expensive operation for the CPU,
and any rounding mode can be implemented as an adjustment of the resulting quotient
by at most \tcode{1},
which is relatively simple (\ref[#implementation]).

\h3{Naming}

All functions which compute a quotient begin with \tcode{div},
and functions which compute a remainder begin with \tcode{rem}.
Furthermore, the functions include the name of the rounding mode
in a format that requires as little prior knowledge as feasible.

Functions which compute a remainder are named after how the remainder obtains its sign.

\h4{Isn't \tcode{std::div_*} inconsistent with the existing \tcode{std::div}?}

It is worth pointing out that there already exist \tcode{std::div}
functions in the standard library, returning \tcode{std::div_t},
which contains the quotient and remainder.
The proposal does not aim for consistency because the facilities are an unnecessary
and rarely-used C relic for the most part.

On the contrary, when investigating existing practice in \ref[#trivial-for-user],
I found that almost every use definition for these differently-rounded division functions
uses \tcode{div_*} names.
This naming scheme is \em{well-established} and \em{intuitive} for users.

\h4{Should it be \tcode{std::div_floor} and \tcode{std::div_ceil}?}

While the use of names like \tcode{floor} and \tcode{ceil} is common in various domains,
including in \header{cmath},
I do not believe we should perpetuate this design because:

\ul{
\li{
The scheme does not nicely extend to division with rounding away from zero;
there is no established term for that.
}
\li{
A hypothetical \tcode{std::div_round} (for rounding to the nearest integer)
would be somewhat perplexing because \em{all} proposed functions round,
just towards different targets.
}
\li{
The scheme is needlessly hostile towards novices
who are not yet familiar with the fact that \math{\mrow{\mi{floor}\mo{(}\mi{x}\mo{)}}}
rounds towards negative infinity.
By comparison, \tcode{std::div_to_neg_inf} is self-documenting.
}
}

Regardless whether the functions end up called \tcode{std::div_floor}
or \tcode{std::div_to_neg_inf}, the names should remain somewhat brief so they take up
a reasonable amount of space in C++ expressions.

\h4{Should it be \tcode{std::div_to_pos_inf}?}

While it looks nicer on paper if \tcode{std::div_to_pos_inf}
and \tcode{std::div_to_neg_inf} have symmetrical names,
this does not have any clear technical benefit to the user.
\tcode{std::div_to_inf} is sufficiently clear,
and adding \tcode{pos} would merely make the function name longer.

\h3{Interface}

The functions generally match the style of similar features in \header{numeric},
like \eelis{numeric.sat} or \eelis{numeric.ops.gcd}.

\example{
A function which computed the quotient rounded towards zero is declared as follows:
\cppblock{
template<class T>
constexpr T div_to_zero(T x, T y) /* not noexcept */;
}
It is constrained to accept only signed or unsigned integer types.
}

These functions are not \tcode{noexcept} because they could not have a wide contract;
they naturally have undefined behavior for cases like \tcode{div_to_zero(x, 0)}
or \tcode{div_to_zero(INT_MIN, -1)}.

However, an invocation of these functions is not a constant expression for such inputs;
i.e. we don't get undefined behavior during constant evaluation.

\h4{Why no \tcode{std::rounding} parameter?}

As compared to \ref[P0105R1],
I do not propose that the rounding mode is passed as a runtime parameter.

In virtually every case, the rounding mode for an integer division is a fixed choice.
This is evidenced by the ten trillion existing uses of the \tcode{/} operator
which \em{always} truncate.
Also, the implementation of the proposed functions does not lend itself to a runtime parameter:

\cppblock{
int div_to_zero(int x, int y) {
    return x / y;
}

int div_to_neg_inf(int x, int y) {
    bool quotient_negative = (x ^ y) < 0;
    return (x / y) - int(x % y != 0 && quotient_negative);
}

int div_away_zero(int x, int y) {
    constexpr auto sgn = [](int z) { return z < 0 ? -1 : 1; };
    int quotient_sign = sgn(x) * sgn(y);
    return (x / y) + int(x % y != 0) * quotient_sign;
}
}
As can be seen, these implementations are substantially different.

\note{
While \tcode{div_to_neg_inf} could \em{theoretically} use the \tcode{quotient_sign} instead,
it requires more operations to compute this positive/negative sign instead of merely checking
whether the quotient is negative.
This would be an unnecessary performance penalty.

In practice, compilers optimize \tcode{sgn(x) * sgn(y) < 0}
strictly worse than \tcode{(x ^ y) < 0}.
}

If we now provided a runtime \tcode{std::rounding},
the obvious implementation would look like:

\cppblock{
enum struct rounding { to_zero, to_neg_inf, away_zero, /* ... */ };

int divide(int x, int y, rounding_mode mode) {
    switch (mode) {
    case rounding::to_zero: return __div_to_zero(x);
    case rounding::to_neg_inf: return __div_to_neg_inf(x);
    case rounding::away_zero:  return __div_away_zero(x);
    // ...
    }
    std::unreachable();
}
}

The user can trivially make such an \tcode{enum class} and \tcode{switch} themselves,
if they actually need to.
If they don't (which is likely),
all we accomplish is making the user write
\tcode{std::divide(std::rounding::to_neg_inf, x, y)} instead of
\tcode{std::div_to_neg_inf(x, y)}.

\h3{Supported rounding modes}

It is apparent that the proposals contains quite a lot of rounding modes
\N{EN DASH} more than just the traditional \tcode{ceil}, \tcode{floor}, \tcode{round}.
It is therefore valid to ask:

\blockquote{Do we really need all these rounding modes?}

All proposed "top-level rounding modes" have practical applications.
For consistency, the same set of "tie-breaking rounding modes" is provided.
In any case, the implementation of these modes is all fairly similar,
and there is neither any significant implementation cost (\ref[#implementation])
nor wording cost (\ref[#wording])
to having a few extra functions.
This would be a much different discussion for floating-point numbers.

I suspect that cherry-picking the "useful" rounding modes out of the proposed ones
would devolve into endless discussion,
and the design would have an inconsistent feel to it if say,
division away from zero was provided,
but no division to the nearest integer with tie breaks away from zero.

\h4{Rounding to zero}

The "trivial" functions \tcode{std::div_to_zero}
and \tcode{std::rem_dividend_sign} exist solely for consistency and enhanced expressiveness.
Note that not every has a truncating integer division like C++.
For example, the \tt{\hl[sym-op]{//}} operator in Python rounds towards negative infinity.
A team of developers with primarily Python experience/habits
may thus benefit from always expressing
rounding mode explicitly with \tcode{std::div_to_zero} to avoid confusion.

\h4{Rounding to even/odd}

Rounding to even/odd integers is mainly useful because it is unbiased.
That is, when dividing a large amount of integers,
results would not gravitate towards one end due to rounding mode bias towards zero, infinity, etc.
This may be important when operating on fixed-point numbers.

\ref[P0105R1] provides additional motivation and explanation of these rounding modes.

\h4{To-nearest-rounding division and tie breaking}

Saying "round to nearest" is not clear enough in itself
because ties (where the fractional part of the quotient is exactly \tcode{.5})
could also be resolved in multiple ways.
Any of the "top-level rounding modes" could plausibly be chosen
as a "tie-breaking rounding mode" as well,
which is what this proposal offers.

\h3{Why the asymmetry between \tcode{div} and \tcode{rem}?}

It would also be plausible to use names like
\tcode{std::rem_to_neg_inf} instead of \tcode{std::rem_divisor_sign},
which is obviously more symmetrical.
However, this may be confusing in practice
because we typically avoid use of \tcode{\N{PERCENT SIGN}} due to its sign being negative.

What the user \em{actually} wants is a function that gives them a positive remainder,
or a remainder with the sign of the divisor.
The obvious naming choice is therefore \tcode{std::rem_positive}.

\note{
An always-positive remainder is the remainder of Euclidean division
and would have no \tcode{std::div_} counterpart.
}

Furthermore, most of the \tcode{std::div} functions do not have a remainder with useful
sign properties, so it is typically sufficient to compute it using the quotient.
The implementation of \tcode{std::div} and \tcode{std::rem} functions also
tends to be asymmetrical.

\example{
\tcode{std::rem_positive} can be implemented as follows,
and the approach used here looks nothing like Euclidean division.

\cppblock{
int rem_positive(int x, int y) {
    int rem = x % y;
    // effectively, this adds abs(y) when rem is negative,
    // but overflow-safely, and avoiding the UB of abs(INT_MIN)
    return int(unsigned(rem) + unsigned(rem < 0) * (y < 0 ? -unsigned(y) : unsigned(y)));
}
}
}

In summary, symmetrical names would hint at a symmetry in implementation and usefulness,
neither of which exist.

\h3{Why no combined remainder and quotient?}

The asymmetry in the previous section largely explains why we don't provide
functions which compute the remainder and quotient at the same time.
In practice, the remainder is only commonly needed for certain rounding modes,
not for all proposed ones.

In practice, separate invocations of \tcode{std::div_to_neg_inf} and \tcode{std::rem_divisor_sign}
optimize the same as a dedicated function
which computes the quotient and remainder simultaneously.

\example{
In the following code, \tcode{remquo_to_neg_inf_1} and \tcode{remquo_to_neg_inf_2}
produce bit-identical assembly output (\ref[CompilerExplorerRemQuo]).
\cppblock{
struct div_t {
    int quotient, remainder;
};

// The user can obviously write this themselves \N{HORIZONTAL ELLIPSIS}
div_t remquo_to_neg_inf_1(int x, int y) {
    // see \ref[#implementation] for definitions of these
    return { div_to_neg_inf(x, y), rem_divisor_sign(x, y) };
};

// \N{HORIZONTAL ELLIPSIS} so we don't need to provide this:
div_t remquo_to_neg_inf_2(int x, int y) {
    int quotient_negative = (x ^ y) < 0;
    bool adjust = x % y != 0 && quotient_negative;
    return {
        .quotient  = x / y - int(adjust),
        .remainder = x % y + int(adjust) * y,
    };
};
}
}

For a lot of the other functions in \ref[#implementation],
the adjustments made to the initial result of \tcode{/} are so complex
that it would not be beneficial to adjust the remainder simultaneously.
In any case, the remainder can be computed using \tcode{x - quotient * y},
which has relatively low cost compared performing the integer division in the first place.
That low cost is why some architectures (e.g. ARM) do not have a dedicated instruction
for computing the remainder (and the remainder is not a side product of division).

In conclusion, functions for computing the quotient and remainder simultaneously
are of unclear utility for many of the rounding modes,
and are driven by a micro-optimization which is insignificant for modern CPUs and architectures.

\h2{Implementation experience}

A reference implementation can be found in \ref[#implementation].
The functions listed there have been tested for correctness.
At least Clang compiler emits entirely branchless code for all functions,
and they merely require a single integer division.

Note that the listed functions are not templates;
they work exclusively with \tcode{int}.
However, making the functions use \tcode{typename T} instead of \tcode{int} is the easy part.
The hard part is coming up with a robust, high-performance sequence of operations.

\h2{Try it yourself}

\style{
.int-input {
    background: none;
    border: 1px solid var(--border-color);
    font-family: var(--monospace-family);
    text-align: right;
    width: fit-content;
    min-width: 2em;
    color: inherit;
}
}

If you have JavaScript enabled,
you can play around with the following code block.
\cppblock{
int x = \html-input[id=x-input,class=int-input,type=number,value=-12];
int y = \html-input[id=y-input,class=int-input,type=number,value=5];

// input expression             \N{RIGHTWARDS ARROW}  output
double(x) / double(y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-double]{-2.4}}

std::div_to_zero(x, y)          \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-trunc]{-2}} // x / y
std::div_away_zero(x, y)        \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-mag]{-3}}
std::div_to_inf(x, y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ceil]{-2}}
std::div_to_neg_inf(x, y)       \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-floor]{-3}}
std::div_to_odd(x, y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-odd]{-3}}
std::div_to_even(x, y)          \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-even]{-2}}

std::div_ties_to_zero(x, y)     \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-trunc]{-2}}
std::div_ties_away_zero(x, y)   \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-mag]{-2}}
std::div_ties_to_inf(x, y)      \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-ceil]{-2}}
std::div_ties_to_neg_inf(x, y)  \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-floor]{-2}}
std::div_ties_to_odd(x, y)      \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-odd]{-2}}
std::div_ties_to_even(x, y)     \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-even]{-2}}

std::rem_dividend_sign(x, y)    \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=rem-trunc]{-2}} // x % y
std::rem_divisor_sign(x, y)     \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=rem-floor]{3}}
std::rem_positive(x, y)         \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=rem-euclid]{3}}
}

\note{
This demonstration conveniently ignores that \tcode{int} has finite size.
Under the hood, calculations are performed using JavaScript's \tt{BigInt}.
}

\script{\include{intdiv.js}}

\h2{Wording}

All changes are relative to \ref[N5008].

In \eelis{structure.specifications#3},
add a bullet immediately following bullet 3.4:

\macro[\constexpects]{\Fundesc{Constant-checked preconditions}}

\diff{
\ul{
\li{
\expects
conditions that the function assumes to hold whenever it is called;
violation of any preconditions results in undefined behavior.
}
\li{\hardexpects [\N{HORIZONTAL ELLIPSIS}]}
\li{\ins{
\constexpects
equivalent to a \Fundescx{Preconditions} specification,
except that a function call expression that violates the assumed condition
is not a core constant expression\iref{expr.const}.
}}
}
}

Change \eelis{structure.specifications#4} as follows:

\diff{
Whenever the \Fundescx{Effects} element specifies that the semantics of some function
\tcode{F} are \term{Equivalent to} some code sequence, then the various elements are
interpreted as follows.
If \tcode{F}'s semantics specifies any \Fundescx{Constraints} or \Fundescx{Mandates} elements,
then those requirements are logically imposed prior to the \term{equivalent-to} semantics.
Next, the semantics of the code sequence are determined by the
\Fundescx{Constraints},
\Fundescx{Mandates},
\Fundescx{Preconditions},
\Fundescx{Hardened preconditions},
\ins{\Fundescx{Constant-checked preconditions},}
\Fundescx{Effects},
\Fundescx{Synchronization},
\Fundescx{Postconditions},
\Fundescx{Returns},
\Fundescx{Throws},
\Fundescx{Complexity},
\Fundescx{Remarks}, and
\Fundescx{Error conditions}
specified for the function invocations contained in the code sequence.
The value returned from \tcode{F} is specified by \tcode{F}'s \Fundescx{Returns} element,
or if \tcode{F} has no \Fundescx{Returns} element,
a non-\tcode{void} return from \tcode{F} is specified by the
\tcode{return} statements\iref{stmt.return} in the code sequence.
If \tcode{F}'s semantics contains a \Fundescx{Throws},
\Fundescx{Postconditions}, or \Fundescx{Complexity} element,
then that supersedes any occurrences of that element in the code sequence.
}

Change the synopsis in \eelis{version.syn} as follows:

\diff{
\itemdecl{
#define __cpp_lib_integer_comparison_functions      202002L // \serif{also in }<utility>
\ins{#define __cpp_lib_integer_division                  20XXXXL // \serif{freestanding, also in }<numeric>}
#define __cpp_lib_integer_sequence                  201304L // \serif{freestanding, also in }<utility>
}
}

Change \eelis{bit.pow.two#5} as follows:

\diff{
\del{\expects} \ins{\constexpects}
\math{\mi{N}} is representable as a value of type \tcode{T}.
}

Delete \eelis{bit.pow.two#8}:

\delblock{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.
}

Change the synopsis in \eelis{numeric.ops.overview} as follows:

\diff{
\itemdecl{
namespace std {
  \html{[\N{HORIZONTAL ELLIPSIS}]}

  // \serif{[numeric.sat], saturation arithmetic}
  template<class T>
    constexpr T add_sat(T x, T y) noexcept;
  template<class T>
    constexpr T sub_sat(T x, T y) noexcept;
  template<class T>
    constexpr T mul_sat(T x, T y) noexcept;
  template<class T>
    constexpr T div_sat(T x, T y) noexcept;
  template<class T, class U>
    constexpr T saturate_cast(U x) noexcept;

\ins{  // \serif{[numeric.int.div], integer division quotients}
  template<class T>
    constexpr T div_to_zero(T x, T y);
  template<class T>
    constexpr T div_away_zero(T x, T y);
  template<class T>
    constexpr T div_to_inf(T x, T y);
  template<class T>
    constexpr T div_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_to_odd(T x, T y);
  template<class T>
    constexpr T div_to_even(T x, T y);
  template<class T>
    constexpr T div_ties_to_zero(T x, T y);
  template<class T>
    constexpr T div_ties_away_zero(T x, T y);
  template<class T>
    constexpr T div_ties_to_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_odd(T x, T y);
  template<class T>
    constexpr T div_ties_to_even(T x, T y);

  // \serif{[numeric.int.rem], integer division remainders}
  template<class T>
    constexpr T rem_dividend_sign(T x, T y);
  template<class T>
    constexpr T rem_divisor_sign(T x, T y);
  template<class T>
    constexpr T rem_positive(T x, T y);}
}
}
}

Change \eelis{numeric.sat.func#9} as follows:

\diff{
\del{\expects} \ins{\constexpects}
\tcode{y != 0} is \tcode{true}.
}

Delete \eelis{numeric.sat.func#11}:

\delblock{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.   
}

Append a new subclause to \eelis{numeric.ops},
following \eelis{numeric.sat}:

\insblock{
\html-h2[style = margin-bottom:0]{Integer division \stable-ref{numeric.int}}

\html-h3[style = margin-top:0.5em]{Integer division quotients \stable-ref{numeric.int.div}}
\Vset[pnum]{0}

\macro[\div-returns{rounding}]{\returns \math{\mfrac{\mi{x}\mi{y}}}, rounded \put{}.}
\macro[\div-returns-nearest{rounding}]{
\returns \math{\mfrac{\mi{x}\mi{y}}}, rounded towards the nearest integer.
If two integers are equidistant, the result is \put{}.
}
\macro[\div-constraints]{\constraints
\tcode{T} is a signed or unsigned integer type\iref{basic.fundamental}.}

\itemdecl{
template<class T>
  constexpr T div_to_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{toward zero}\br
\wg21-note{
The result is equivalent to \tcode{x / y}.
}
}

\itemdecl{
template<class T>
  constexpr T div_away_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{away from zero}
}

\itemdecl{
template<class T>
  constexpr T div_to_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards positive infinity}
}

\itemdecl{
template<class T>
  constexpr T div_neg_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards negative infinity}
}

\itemdecl{
template<class T>
  constexpr T div_to_odd(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards the nearest odd integer}
}

\itemdecl{
template<class T>
  constexpr T div_to_even(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards the nearest even integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the integer with lower magnitude}
}

\itemdecl{
template<class T>
  constexpr T div_ties_away_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the integer with greater magnitude}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the greater integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_neg_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the lower integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_odd(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the odd integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_even(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the even integer}
}

\html-h3{Integer division remainders \stable-ref{numeric.int.rem}}
\Vset[pnum]{0}

\itemdecl{
template<class T>
  constexpr T rem_dividend_sign(T x, T y);
}

\itemdescr{
\pnum
\effects
Equivalent to \tcode{x - y * div_to_zero(x, y)}.
\br\wg21-note{
The result is equal to \tcode{x \N{PERCENT SIGN} y},
and is negative if and only if \tcode{x} is negative.
}
}

\itemdecl{
template<class T>
  constexpr T rem_divisor_sign(T x, T y);
}

\itemdescr{
\pnum
\effects
Equivalent to \tcode{x - y * div_to_neg_inf(x, y)}.
\br\wg21-note{
The result is negative if and only if \tcode{y} is negative.
}
}

\itemdecl{
template<class T>
  constexpr T rem_positive(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x \N{PERCENT SIGN} y} is well-defined.

\pnum
\effects
Equivalent to:
\indent{\itemdecl{
T r = x % y;
return r >= 0 ? r
     : y >= 0 ? r + y
              : r - y;
}}
\br
\wg21-note{
The result is the remainder of the Euclidean division \math{\mfrac{\mi{x}\mi{y}}}.
The result is always positive.
}
}

}

\warning{
If the mathematical notation in the block above does not render for you,
you are using an old browser with no MathML support.
Please open the document in a recent version of Firefox or Chrome.
}

Change \eelis{simd.bit#4} as follows:

\diff{
\del{\expects} \ins{\constexpects}
For every \math{\mi{i}} [\N{HORIZONTAL ELLIPSIS}].
}

Delete \eelis{simd.bit#6}:

\delblock{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.   
}

\h2{References}

\bib[
    id = N5008,
    title = Working Draft\, Programming Languages — C++,
    date = 2025-03-15,
    author = Thomas Köppe,
    link = https://wg21.link/n5008,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf
]
\bib[
    id = P0105R1,
    title = Rounding and Overflow in C++,
    date = 2017-02-05,
    author = Lawrence Crowl,
    link = https://wg21.link/p0105r1,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0105r1.html
]
\bib[
    id = P1889R1,
    title = C++ Numerics Work In Progress,
    date = 2019-12-27,
    author = Alexander Zaitsev,
    link = https://wg21.link/p1889r1,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1889r1.pdf
]
\bib[
    id = StackOverflowDivision,
    title = Fast ceiling of an integer division in C / C++,
    link = https://stackoverflow.com/q/2745074/5740428
]
\bib[
    id = BuggyDivisions,
    author = njohnny84,
    title = Rounding Modes For Integer Division,
    link = https://blog.demofox.org/2022/07/21/rounding-modes-for-integer-division/
]
\bib[
    id = CompilerExplorerRemQuo,
    author = Jan Schultke,
    link = https://godbolt.org/z/vTPq9eGP6
]

\make-bib

\h2[id=implementation]{Appendix A \N{EM DASH} Reference implementation}

\macro[\sgn2]{\exposid{sgn}}

\cppblock{\include{intdiv.cpp}}

\note{
Since integer division occurs unconditionally in these functions,
they also trivially satisfy the \ref[#wording] requirement that invocations of these functions
are not constant expressions when the result is not representable.
}

\comment{https://godbolt.org/z/TY5h34jG3}
