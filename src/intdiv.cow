\import{libwg21.cow}

\wg21-head[
    title = Integer division
]{
\dl{
    \dt{Document number:} \dd{\docnum{P3724R0}}
    \dt{Date:}            \dd{\tt{2025-05-30}}
    \dt{Audience:}        \dd{LEWG, SG6}
    \dt{Project:}         \dd{ISO/IEC 14882 Programming Languages â€” C++, ISO/IEC JTC1/SC22/WG21}
    \dt{Reply-To:}        \dd{Jan Schultke <\mail{janschultke@gmail.com}>}
    \dt{GitHub Issue:}    \dd{\ref[https://wg21.link/P3724/github]}
    \dt{Source:}          \dd{\ref[https://github.com/Eisenwave/cpp-proposals/blob/master/src/intdiv.cow]}
}
\hr
}

\abstract{
C++ currently only offers truncating integer division in the form of the \tcode{/} operator.
I propose standard library functions for computing quotients and remainders
with other rounding modes.
}

\h2[listed=no]{Contents}

\make-contents

\h2{Introduction}

C++ currently only offers truncating integer division in the form of the \tcode{/} operator.
However, other rounding modes have various use cases too,
and implementing these as the user can be surprisingly hard,
especially when integer overflow needs to be avoided,
and negative inputs are accepted.

Furthermore, since the \tcode{/} operator rounds towards zero,
the \tcode{\N{PERCENT SIGN}} (remainder) operator may yield negative results
(specifically, when the dividend is negative).
In modular arithmetic and various other use cases,
this is undesirable,
and a negative remainder may be surprising in general.

Therefore, I propose a set of standard library functions
which implement a variety of rounding modes when computing quotients and remainders.
Such a feature was previously part of \ref[P0105R1] and the Numerics TS \ref[P1889R1],
but was eventually abandoned by the author,
in part due to design disagreements.

\note{
Terminology refresher for division, where
\math{\mi[style=font-style:italic]{round}}
is some rounding function:
\mathblock{\mrow{
    \mi{quotient}
    \mo{=}
    \mi[style=font-style:italic]{round}
    \mo{(}
    \mfrac{\mi{dividend}\mi{divisor}}
    \mo{)}
    \mo{+}
    \mi{remainder}
}}
Your browser requires MathML support to view the equation above.
}

\h3{Existing practice}

To better put this proposal into context,
it is relevant to know what rounding modes are usually supported by programming languages
and hardware.

\style{
.center {
    margin-left: auto;
    margin-right: auto;
}

td ul, td ul>li {
    margin: 0;
}

#lang-comparison td:nth-child(2),
#lang-comparison td:nth-child(3) {
    text-align: center;
}

#hw-comparison td:nth-child(2),
#hw-comparison td:nth-child(3),
#hw-comparison td:nth-child(4) {
    text-align: center;
}

#lang-comparison, #hw-comparison {
    min-width: 75%;
}

.striped tr:nth-child(even) td {
    background-color: var(--deep-background-color);
}
}

\macro[\neg-inf]{\math{\mrow{\mo{\N{MINUS SIGN}}\mi{\N{INFINITY}}}}}
\macro[\pos-inf]{\math{\mrow{\mo{+}\mi{\N{INFINITY}}}}}

\h4[id=language-support]{Language support for integer division}

\table[id=lang-comparison, class = center striped]{
\tr{
    \th{Language} \th{Quotient} \th{Remainder} \th{Rounding}
}
\tr{
    \td{C and C++}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{D}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{C#}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Java}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Kotlin}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Rust}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Go}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Swift}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{Scala}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{OCaml}
    \td{\tt{/}}
    \td{\tt{mod}}
    \td{to zero}
}
\tr{
    \td{Perl}
    \td{\tt{int($a/$b)}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero}
}
\tr{
    \td{JavaScript}
    \td{\tt{/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to zero (for \tt{BigInt} operands)}
}
\tr{
    \td{Python}
    \td{\tt{//}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to \neg-inf}
}
\tr{
    \td{Lua}
    \td{\tt{//}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to \neg-inf}
}
\tr{
    \td{R}
    \td{\tt{\N{PERCENT SIGN}/\N{PERCENT SIGN}}}
    \td{\tt{\N{PERCENT SIGN}\N{PERCENT SIGN}}}
    \td{to \neg-inf}
}
\tr{
    \td{Dart}
    \td{\tt{~/}}
    \td{\tt{\N{PERCENT SIGN}}}
    \td{to \neg-inf}
}
\tr{
    \td{Haskell}
    \td{\tt{quot}, \tt{div}}
    \td{\tt{rem}, \tt{mod}}
    \td{\ul{
        \li{\tt{quot} and \tt{rem} to zero}
        \li{\tt{div} and \tt{mod} to \neg-inf}
    }}
}
\tr{
    \td{Ada}
    \td{\tt{/}}
    \td{\tt{rem}, \tt{mod}}
    \td{\ul{
        \li{\tt{/} and \tt{rem} to zero}
        \li{\tt{mod} to \neg-inf}
    }}
}
\tr{
    \td{Fortran}
    \td{\tt{/}}
    \td{\tt{mod}, \tt{modulo}}
    \td{\ul{
        \li{\tt{/} and \tt{mod} to zero}
        \li{\tt{modulo} to \neg-inf}
    }}
}
\tr{
    \td{Julia}
    \td{\tt{div(x,y,r)}}
    \td{\tt{rem(x,y,r)}}
    \td{
        depending on \tt{RoundingMode} \tt{r}:\ul{
            \li{to zero (default),}
            \li{away from zero,}
            \li{to \pos-inf or \neg-inf, or}
            \li{to nearest (ties to even)}
        }
    }
}
}

\note{
When a division rounds towards zero,
the remainder has the dividend (left operand) sign.
When a division rounds towards \neg-inf,
the remainder has the divisor (right operand) sign.
}

\h4{Hardware support for integer division}

\table[id=hw-comparison, class = center striped]{
\tr{
    \th{Architecture} \th{Type} \th{Quotient} \th{Remainder} \th{Rounding}
}
\tr{
    \td{x86 and x86_64}
    \td{CPU}
    \td{\tt{idiv}, \tt{div}}
    \td{\tt{idiv}, \tt{div}}
    \td{to zero}
}
\tr{
    \td{ARM}
    \td{CPU}
    \td{\tt{sdiv}, \tt{udiv}}
    \td{N/A}
    \td{to zero}
}
\tr{
    \td{RISC-V}
    \td{CPU}
    \td{\tt{div}, \tt{divu}}
    \td{\tt{rem}, \tt{remu}}
    \td{to zero}
}
\tr{
    \td{PowerPC}
    \td{CPU}
    \td{\tt{divw}, \tt{divwu}}
    \td{N/A}
    \td{to zero}
}
\tr{
    \td{MIPS}
    \td{CPU}
    \td{\tt{div}, \tt{divu}}
    \td{\tt{div}, \tt{divu},\br\tt{rem}, \tt{remu}}
    \td{to zero}
}
\tr{
    \td{AVR (8-bit)}
    \td{CPU}
    \td{N/A}
    \td{N/A}
    \td{N/A}
}
\tr{
    \td{WebAssembly}
    \td{VM}
    \td{\tt{div_s}, \tt{div_u}}
    \td{\tt{rem_s}, \tt{rem_u}}
    \td{to zero}
}
\tr{
    \td{LLVM IR}
    \td{VM}
    \td{\tt{sdiv}, \tt{udiv}}
    \td{\tt{srem}, \tt{urem}}
    \td{to zero}
}
\tr{
    \td{Java Bytecode}
    \td{VM}
    \td{\tt{idiv}}
    \td{\tt{irem}}
    \td{to zero}
}
}

\note{
For unsigned division like \tt{div} on x86,
there is no distinction between rounding to zero and rounding to \neg-inf{},
which is why everything is listed as "to zero" for simplicity.
}

While every architecture rounds to zero,
there there are major differences in how the remainder is obtained:
\ul{
    \li{On x86_64 and MIPS, the quotient and remainder are computed simultaneously,
    although MIPS also supports separate computation of the remainder.}
    \li{On other architectures, even if there is support for computing the remainder separately,
    if both the quotient and remainder are needed,
    it is faster to compute the remainder using the quotient of the division.}
    \li{In some cases, the remainder can \em{only} be computed using the quotient.}
}

\note{
Given two integers \math{\mi{x}} and \math{\mi{y}},
the quotient \math{\mrow{
    \mi{q}
    \mo{=}
    \mo{\N{LEFT FLOOR}}
    \mfrac{\mi{x}\mi{y}}
    \mo{\N{RIGHT FLOOR}}
}} (or rounded otherwise to an integer),
the remainder of the division is equal to
\math{\mrow{
    \mi{x}
    \mo{\N{MINUS SIGN}}
    \mi{y}
    \mo{\N{MULTIPLICATION SIGN}}
    \mi{q}
}}\N{ZERO-WIDTH NO-BREAK SPACE}.

\em{Only} if the division rounds towards zero can this also be translated literally
into a multiplication and subtraction,
without the possibility of overflow.
This makes rounding towards zero \em{by far} the most useful rounding mode in computing,
and it is no coincidence that every architecture implements it.
}

\h2{Motivation}

Rounding modes other than rounding towards zero are commonly useful.
An extremely common alternative is rounding towards \neg-inf,
which is the rounding mode of the division operator in some other languages
(\ref[#language-support]).
See below for some motivating examples.

\example{
A common problem is to compute how many chunks/buckets/blocks of a fixed size
are needed to fit a certain amount of elements,
which involves a division which rounds towards positive infinity.
\cppblock{
const int bucket_size = 1000;
int elements = 100;

int buckets_required = elements / bucket_size; // WRONG, zero
int buckets_required = std::div_to_inf(elements, bucket_size); // OK, one bucket
}
}

\example{
A common problem is to compute which chunk/bucket/block an element falls into.
This requires division which rounds towards negative infinity.
\cppblock{
const int bucket_size = 1000;
int a = 10;
int b = -10;

int a_bucket = a / bucket_size; // OK, zero
int b_bucket = b / bucket_size; // WRONG, also zero

int a_bucket = std::div_to_neg_inf(a, bucket_size); // OK, zero
int b_bucket = std::div_to_neg_inf(b, bucket_size); // OK, -1
}
Note that with truncating division,
the zero-bucket would contain all elements in [-999, 999],
which would make it larger than any other bucket.
}

While the examples are somewhat abstract,
they appear in vast amounts of concrete problems.
For example, we need to know how many blocks of memory must be allocated
to hold a certain amount of bytes,
do interval arithmetic,
fixed-point arithmetic with rounding of choice, etc. etc.

\h3[id=trivial-for-user]{Is this not trivial for the user to do?}

At first glance,
it would seem trivial to change rounding modes by making slight adjustments to \tcode{/}.
However, doing so with correct output, high performance,
and without introducing more undefined behavior than \tcode{x / y} already has,
is surprisingly hard.

There is an \em{ocean} of examples where C++ users have gotten this wrong.
A few droplets are listed below.

\bug{
At the time of writing,
the \em{first} Google search result for "c++ ceiling integer division"
yields \ref[StackOverflowDivision].
Almost every answer does not permit signed integers,
gives wrong results,
or has undefined behavior for certain inputs
(not counting division by zero or \tcode{\hl[macro]{INT_MIN} / -1}).

For example, one answer with 67 upvotes (at the time of writing)
attempts to implement ceiling (rounded towards positive infinity)
integer division as follows:
\cppblock{
q = (x % y) ? x / y + 1 : x / y;
}
The quotient \tcode{q} would be \tcode{1}, not \tcode{0}
for inputs \tcode{x = -1} and \tcode{y = 2},
which is obviously wrong because it rounds \tcode{-0.5} up to \tcode{1}, skipping zero.

To be fair, the answer is correct for positive integers,
and perhaps the author didn't want to support negative inputs anyway.
However, the answer contains no disclaimer that clarifies this.
}

\bug{
These division functions taken from \ref[BuggyDivisions] have several problems:
\cppblock{
static int div_floor(int a, int b) {
    return (a ^ b) < 0 && a ? (1 - abs(a)) / abs(b) - 1 : a / b;
}

static int div_round(int a, int b) {
    return (a ^ b) < 0 ? (a - b / 2) / b : (a + b / 2) / b;
}

static int div_ceil(int a, int b) {
    return (a ^ b) < 0 || !a ? a / b : (abs(a) - 1) / abs(b) + 1;
}
}
\ul{
\li{\tcode{abs(a)} and \tcode{abs(b)} have undefined behavior given \tcode{\hl[macro]{INT_MIN}} input}
\li{\tcode{div_round} overflows on large inputs in \tcode{a - b} and \tcode{a + b}}
\li{
all functions branch depending on whether the quotient is negative,
and at least for a standard library (which has to cover a wide variety of use cases),
such a branch could be \em{highly} unpredictable
}
}
}

\note{See \ref[#implementation] for proper implementations.}

Users sometimes also implement these functions using \tcode{std::floor} or \tcode{std::ceil},
but this can equally yield incorrect results,
and use of floating-point numbers is unnecessary for this task.

\h3[id=computing-remainders-is-hard]{Computing remainders is hard, actually}

There exist various use cases (modular arithmetic, integer-to-string conversion, etc.)
where we need both the quotient and remainder at the same time.
The naive approach to computing the remainder
using an integer division function \placeholder{divide} looks something like:

\cppblock{
int x = /* ... */, y = /* ... */;
int quotient = \exposid{divide}(x, y);
int remainder = x - quotient * y;
}

This approach is only safe when \tcode{\exposid{divide}(x,y)} is \tcode{x/y},
i.e. when rounding towards zero.

\bug{
The following function, which yields the quotient rounded towards \pos-inf,
as well as the remainder,
is not safe for large inputs:
\cppblock{
std::div_t div_rem_ceil(int x, int y) {
    bool quotient_positive = (x < 0) == (y < 0);
    bool has_remainder = x \N{PERCENT SIGN} y != 0;
    int quotient = x / y + int(quotient_positive && has_remainder);
    int remainder = x - y * quotient;
    return { quotient, remainder };
}
}
If we now call \tcode{div_rem_ceil(\hl[macro]{INT_MAX}, 2)},
where \tcode{\hl[macro]{INT_MAX}} is \tcode{2'147'483'647},
then \tcode{quotient} is \tcode{1'073'741'824}.
The multiplication \tcode{y * quotient} has undefined behavior
because it results in \tcode{2'147'483'648}, which cannot be represented as \tcode{int}.

Crucially, it does not mean that \tcode{div_rem_ceil} cannot be defined for these inputs.
The correct quotient is \tcode{1'073'741'824},
and the correct remainder is \tcode{-1}.
It just means that for any rounding mode except towards zero,
we cannot use the naive formula to obtain a remainder.
}

In conclusion,
the proposal should also include a way to obtain a remainder in tandem with the quotient.
Any other design would simply invite bugs where users foolishly assume that
the \tcode{x - quotient * y} method works for all rounding modes.

\h2{Design}

The design aims of this proposal are to provide \em{concise},
\em{simple}, \em{efficient}, \em{robust} functions
which are useful \em{in practice}.

\important{
As a rule of thumb, the proposed functionality should be a drop-in replacement
for the various bad implementations that users have written themselves (\ref[#trivial-for-user]),
and it should take the underlying implementation (\ref[#implementation]) into consideration.
This rule of thumb influences \em{every} design choice.
}

For example:
\ul{
\li{Names are prefixed with \tcode{div} because this is common practice (\ref[#naming]).}
\li{The \tcode{rem} functions are named after their sign properties,
which is what users are typically interested in (\ref[#div-rem-asymmetry]).}
\li{There are no functions that compute quotient and remainder at the same time (\ref[#why-no-combined]).}
\li{[\N{HORIZONTAL ELLIPSIS}]}
}

\note{
You may find a complete list of functions in
\ref[#try-it-yourself],
\ref[#wording], and
\ref[#implementation].
}

\h3{Relation to P0105R1}

The design somewhat leans on \ref[P0105R1]
(which first proposed division functions with custom rounding),
but heavily deviates from it.
In general, \ref[P0105R1] was a proposal with overly broad scope,
and some questionable design choices, such as:

\ul{
\li{Making some of the rounding modes conditionally supported,
even when providing them isn't particularly difficult.}
\li{Adding rounding modes which optimize for latency or code size,
without much motivation or details.
The \tcode{/} and \tcode{\N{PERCENT SIGN}} operators already match the rounding mode
of hardware division on mainstream architectures,
so it's unclear how a library function could be faster.}
}

\h3{Naming}

All functions which compute a quotient begin with \tcode{div},
and functions which compute a remainder begin with \tcode{rem}.
Furthermore, the functions include the name of the rounding mode
in a format that requires as little prior knowledge as feasible.

Functions which compute a remainder are named after how the remainder obtains its sign.

\h4{Isn't \tcode{std::div_*} inconsistent with the existing \tcode{std::div}?}

It is worth pointing out that there already exist \tcode{std::div}
functions in the standard library, returning \tcode{std::div_t},
which contains the quotient and remainder.
The proposal does not aim for consistency because the facilities are an unnecessary
and rarely-used C relic for the most part.

On the contrary, when investigating existing practice in \ref[#trivial-for-user],
I found that almost every use definition for these differently-rounded division functions
uses \tcode{div_*} names.
This naming scheme is \em{well-established} and \em{intuitive} for users.

\h4{Should it be \tcode{std::div_floor} and \tcode{std::div_ceil}?}

While the use of names like \tcode{floor} and \tcode{ceil} is common in various domains,
including in \header{cmath},
I do not believe we should perpetuate this design because:

\ul{
\li{
The scheme does not nicely extend to division with rounding away from zero;
there is no established term for that.
}
\li{
A hypothetical \tcode{std::div_round} (for rounding to the nearest integer)
would be somewhat perplexing because \em{all} proposed functions round,
just towards different targets.
}
\li{
The scheme is needlessly hostile towards novices
who are not yet familiar with the fact that \math{\mrow{\mi{floor}\mo{(}\mi{x}\mo{)}}}
rounds towards negative infinity.
By comparison, \tcode{std::div_to_neg_inf} is self-documenting.
}
}

Regardless whether the functions end up called \tcode{std::div_floor}
or \tcode{std::div_to_neg_inf}, the names should remain somewhat brief so they take up
a reasonable amount of space in C++ expressions.

\h4{Should it be \tcode{std::div_to_pos_inf}?}

While it looks nicer on paper if \tcode{std::div_to_pos_inf}
and \tcode{std::div_to_neg_inf} have symmetrical names,
this does not have any clear technical benefit to the user.
\tcode{std::div_to_inf} is sufficiently clear,
and adding \tcode{pos} would merely make the function name longer.

\h3{Interface}

The functions generally match the style of similar features in \header{numeric},
like \eelis{numeric.sat} or \eelis{numeric.ops.gcd}.

\example{
A function which computed the quotient rounded towards zero is declared as follows:
\cppblock{
template<class T>
constexpr T div_to_zero(T x, T y) /* not noexcept */;
}
It is constrained to accept only signed or unsigned integer types.
}

These functions are not \tcode{noexcept} because they could not have a wide contract;
they naturally have undefined behavior for cases like \tcode{div_to_zero(x, 0)}
or \tcode{div_to_zero(\hl[macro]{INT_MIN}, -1)}.

However, an invocation of these functions is not a constant expression for such inputs;
i.e. we don't get undefined behavior during constant evaluation.

\h4{Why no \tcode{std::rounding} parameter?}

As compared to \ref[P0105R1],
I do not propose that the rounding mode is passed as a runtime parameter.

In virtually every case, the rounding mode for an integer division is a fixed choice.
This is evidenced by the ten trillion existing uses of the \tcode{/} operator
which \em{always} truncate.
Also, the implementation of the proposed functions does not lend itself to a runtime parameter:

\cppblock{
int div_to_zero(int x, int y) {
    return x / y;
}

int div_to_neg_inf(int x, int y) {
    bool quotient_negative = (x ^ y) < 0;
    return (x / y) - int(x % y != 0 && quotient_negative);
}

int div_away_zero(int x, int y) {
    constexpr auto sgn = [](int z) { return z < 0 ? -1 : 1; };
    int quotient_sign = sgn(x) * sgn(y);
    return (x / y) + int(x % y != 0) * quotient_sign;
}
}
As can be seen, these implementations are substantially different.

\note{
While \tcode{div_to_neg_inf} could \em{theoretically} use the \tcode{quotient_sign} instead,
it requires more operations to compute this positive/negative sign instead of merely checking
whether the quotient is negative.
This would be an unnecessary performance penalty.

In practice, compilers optimize \tcode{sgn(x) * sgn(y) < 0}
strictly worse than \tcode{(x ^ y) < 0}.
}

If we now provided a runtime \tcode{std::rounding},
the obvious implementation would look like:

\cppblock{
enum struct rounding { to_zero, to_neg_inf, away_zero, /* ... */ };

int divide(int x, int y, rounding_mode mode) {
    switch (mode) {
    case rounding::to_zero: return __div_to_zero(x);
    case rounding::to_neg_inf: return __div_to_neg_inf(x);
    case rounding::away_zero:  return __div_away_zero(x);
    // ...
    }
    std::unreachable();
}
}

The user can trivially make such an \tcode{enum class} and \tcode{switch} themselves,
if they actually need to.
If they don't (which is likely),
all we accomplish is making the user write
\tcode{std::divide(std::rounding::to_neg_inf, x, y)} instead of
\tcode{std::div_to_neg_inf(x, y)}.

\h3{Supported rounding modes}

It is apparent that the proposal contains quite a lot of rounding modes
\N{EN DASH} more than just the traditional \tcode{ceil}, \tcode{floor}, \tcode{round}.
It is therefore valid to ask:

\blockquote{Do we really need all these rounding modes?}

All proposed "top-level rounding modes" have practical applications.
For consistency, the same set of "tie-breaking rounding modes" is provided.
In any case, the implementation of these modes is all fairly similar,
and there is neither any significant implementation cost (\ref[#implementation])
nor wording cost (\ref[#wording])
to having a few extra functions.
This would be a much different discussion for floating-point numbers.

I suspect that cherry-picking the "useful" rounding modes out of the proposed ones
would devolve into endless discussion,
and the design would have an inconsistent feel to it if say,
division away from zero was provided,
but no division to the nearest integer with tie breaks away from zero.

\h4{Rounding to zero}

The "trivial" functions \tcode{std::div_to_zero}
and \tcode{std::rem_dividend_sign} exist solely for consistency and enhanced expressiveness.
Note that not every has a truncating integer division like C++.
For example, the \tt{\hl[sym-op]{//}} operator in Python rounds towards negative infinity.
A team of developers with primarily Python experience/habits
may thus benefit from always expressing
rounding mode explicitly with \tcode{std::div_to_zero} to avoid confusion.

\h4{Rounding to even/odd}

Rounding to even/odd integers is mainly useful because it is unbiased.
That is, when dividing a large amount of integers,
results would not gravitate towards one end due to rounding mode bias towards zero, infinity, etc.
This may be important when operating on fixed-point numbers.

\ref[P0105R1] provides additional motivation and explanation of these rounding modes.

\h4{To-nearest-rounding division and tie breaking}

Saying "round to nearest" is not clear enough in itself
because ties (where the fractional part of the quotient is exactly \tcode{.5})
could also be resolved in multiple ways.
Any of the "top-level rounding modes" could plausibly be chosen
as a "tie-breaking rounding mode" as well,
which is what this proposal offers.

\h3[id=div-rem-asymmetry]{Why the asymmetry between \tcode{div} and \tcode{rem}?}

It would also be plausible to use names like
\tcode{std::rem_to_neg_inf} instead of \tcode{std::rem_divisor_sign},
which is obviously more symmetrical.
However, this may be confusing in practice
because we typically avoid use of \tcode{\N{PERCENT SIGN}} due to its sign being negative.

What the user \em{actually} wants is a function that gives them a positive remainder,
or a remainder with the sign of the divisor.
The obvious naming choice is therefore \tcode{std::rem_positive}.

\note{
An always-positive remainder is the remainder of Euclidean division
and would have no \tcode{std::div_} counterpart.
}

Furthermore, most of the \tcode{std::div} functions do not have a remainder with useful
sign properties, so it is typically sufficient to compute it using the quotient.
The implementation of \tcode{std::div} and \tcode{std::rem} functions also
tends to be asymmetrical.

\example{
\tcode{std::rem_positive} can be implemented as follows,
and the approach used here looks nothing like Euclidean division.

\cppblock{
int rem_positive(int x, int y) {
    int rem = x % y;
    // effectively, this adds abs(y) when rem is negative,
    // but overflow-safely, and avoiding the UB of abs(INT_MIN)
    return int(unsigned(rem) + unsigned(rem < 0) * (y < 0 ? -unsigned(y) : unsigned(y)));
}
}
}

In summary, symmetrical names would hint at a symmetry in implementation and usefulness,
neither of which exist.

\h3[id=why-no-combined]{Why no combined remainder and quotient?}

The asymmetry in the previous section largely explains why we don't provide
functions which compute the remainder and quotient at the same time.
In practice, the remainder is only commonly needed for certain rounding modes,
not for all proposed ones.

In practice, separate invocations of \tcode{std::div_to_neg_inf} and \tcode{std::mod}
optimize the same as a dedicated function
which computes the quotient and remainder simultaneously.

\example{
In the following code, \tcode{div_rem_to_neg_inf_1} and \tcode{div_rem_to_neg_inf_2}
produce bit-identical assembly output (\ref[CompilerExplorerRemQuo]).
\cppblock{
struct div_t {
    int quotient, remainder;
};

// The user can obviously write this themselves \N{HORIZONTAL ELLIPSIS}
div_t div_rem_to_neg_inf_1(int x, int y) {
    // see \ref[#implementation] for definitions of these
    return { div_to_neg_inf(x, y), mod(x, y) };
}

// \N{HORIZONTAL ELLIPSIS} so we don't need to provide this:
div_t div_rem_to_neg_inf_2(int x, int y) {
    int quotient_negative = (x ^ y) < 0;
    bool adjust = x % y != 0 && quotient_negative;
    return {
        .quotient  = x / y - int(adjust),
        .remainder = x % y + int(adjust) * y,
    };
}
}
}

For a lot of the other functions in \ref[#implementation],
the adjustments made to the initial result of \tcode{/} are so complex
that it would not be beneficial to adjust the remainder simultaneously.
In any case, the remainder can be computed using \tcode{x - quotient * y},
which has relatively low cost compared performing the integer division in the first place.
That low cost is why some architectures (e.g. ARM) do not have a dedicated instruction
for computing the remainder (and the remainder is not a side product of division).

In conclusion, functions for computing the quotient and remainder simultaneously
are of unclear utility for many of the rounding modes,
and are driven by a micro-optimization which is insignificant for modern CPUs and architectures.

\h2{Implementation experience}

A reference implementation can be found in \ref[#implementation].
The functions listed there have been tested for correctness.
At least Clang compiler emits entirely branchless code for all functions,
and they merely require a single integer division.

Note that the listed functions are not templates;
they work exclusively with \tcode{int}.
However, making the functions use \tcode{typename T} instead of \tcode{int} is the easy part.
The hard part is coming up with a robust, high-performance sequence of operations.

\h2{Try it yourself}

\style{
.int-input {
    background: none;
    border: 1px solid var(--border-color);
    font-family: var(--monospace-family);
    text-align: right;
    width: fit-content;
    min-width: 2em;
    color: inherit;
}
}

If you have JavaScript enabled,
you can play around with the following code block.
\cppblock{
int x = \html-input[id=x-input,class=int-input,type=number,value=-12];
int y = \html-input[id=y-input,class=int-input,type=number,value=5];

// input expression             \N{RIGHTWARDS ARROW}  output
double(x) / double(y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-double]{-2.4}}

std::div_to_zero(x, y)          \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-trunc]{-2}} // x / y
std::div_away_zero(x, y)        \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-mag]{-3}}
std::div_to_inf(x, y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ceil]{-2}}
std::div_to_neg_inf(x, y)       \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-floor]{-3}}
std::div_to_odd(x, y)           \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-odd]{-3}}
std::div_to_even(x, y)          \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-even]{-2}}

std::div_ties_to_zero(x, y)     \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-trunc]{-2}}
std::div_ties_away_zero(x, y)   \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-mag]{-2}}
std::div_ties_to_inf(x, y)      \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-ceil]{-2}}
std::div_ties_to_neg_inf(x, y)  \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-floor]{-2}}
std::div_ties_to_odd(x, y)      \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-odd]{-2}}
std::div_ties_to_even(x, y)     \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=quo-ties-even]{-2}}

x \N{PERCENT SIGN} y              \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=rem-trunc]{-2}}
std::mod(x, y)     \N{RIGHTWARDS ARROW}  \hl[number]{\span[id=rem-floor]{3}}
}

\note{
This demonstration conveniently ignores that \tcode{int} has finite size.
Under the hood, calculations are performed using JavaScript's \tt{BigInt}.
}

\script{\include{intdiv.js}}

\h2{Wording}

All changes are relative to \ref[N5008].

\h3{[structure.specifications]}

In \eelis{structure.specifications#3},
add a bullet immediately following bullet 3.4:

\macro[\constexpects]{\Fundesc{Constant-checked preconditions}}

\diff{
\ul{
\li{
\expects
conditions that the function assumes to hold whenever it is called;
violation of any preconditions results in undefined behavior.
}
\li{\hardexpects [\N{HORIZONTAL ELLIPSIS}]}
\li{\ins{
\constexpects
equivalent to a \Fundescx{Preconditions} specification,
except that a function call expression that violates the assumed condition
is not a core constant expression\iref{expr.const}.
}}
}
}

Change \eelis{structure.specifications#4} as follows:

\diff{
Whenever the \Fundescx{Effects} element specifies that the semantics of some function
\tcode{F} are \term{Equivalent to} some code sequence, then the various elements are
interpreted as follows.
If \tcode{F}'s semantics specifies any \Fundescx{Constraints} or \Fundescx{Mandates} elements,
then those requirements are logically imposed prior to the \term{equivalent-to} semantics.
Next, the semantics of the code sequence are determined by the
\Fundescx{Constraints},
\Fundescx{Mandates},
\Fundescx{Preconditions},
\Fundescx{Hardened preconditions},
\ins{\Fundescx{Constant-checked preconditions},}
\Fundescx{Effects},
\Fundescx{Synchronization},
\Fundescx{Postconditions},
\Fundescx{Returns},
\Fundescx{Throws},
\Fundescx{Complexity},
\Fundescx{Remarks}, and
\Fundescx{Error conditions}
specified for the function invocations contained in the code sequence.
The value returned from \tcode{F} is specified by \tcode{F}'s \Fundescx{Returns} element,
or if \tcode{F} has no \Fundescx{Returns} element,
a non-\tcode{void} return from \tcode{F} is specified by the
\tcode{return} statements\iref{stmt.return} in the code sequence.
If \tcode{F}'s semantics contains a \Fundescx{Throws},
\Fundescx{Postconditions}, or \Fundescx{Complexity} element,
then that supersedes any occurrences of that element in the code sequence.
}

\h3{[version.syn]}

Change the synopsis in \eelis{version.syn} as follows:

\diff{
\itemdecl{
#define __cpp_lib_integer_comparison_functions      202002L // \serif{also in }<utility>
\ins{#define __cpp_lib_integer_division                  20XXXXL // \serif{freestanding, also in }<numeric>}
#define __cpp_lib_integer_sequence                  201304L // \serif{freestanding, also in }<utility>
}
}

\h3{[bit.pow.two]}

Change \eelis{bit.pow.two#5} as follows:

\diff{
\del{\expects} \ins{\constexpects}
\math{\mi{N}} is representable as a value of type \tcode{T}.
}

Delete \eelis{bit.pow.two#8}:

\delblock{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.
}

\h3{[numeric.ops.overview]}

Change the synopsis in \eelis{numeric.ops.overview} as follows:

\diff{
\itemdecl{
namespace std {
  \html{[\N{HORIZONTAL ELLIPSIS}]}

  // \serif{[numeric.sat], saturation arithmetic}
  template<class T>
    constexpr T add_sat(T x, T y) noexcept;
  template<class T>
    constexpr T sub_sat(T x, T y) noexcept;
  template<class T>
    constexpr T mul_sat(T x, T y) noexcept;
  template<class T>
    constexpr T div_sat(T x, T y) noexcept;
  template<class T, class U>
    constexpr T saturate_cast(U x) noexcept;

\ins{  // \serif{[numeric.int.div], integer division}
  template<class T>
  struct div_result {
    T quotient;
    T remainder;
    friend bool operator<=>(const div_result&, const div_result&) = default;
  };

  template<class T>
    constexpr T div_to_zero(T x, T y);
  template<class T>
    constexpr T div_away_zero(T x, T y);
  template<class T>
    constexpr T div_to_inf(T x, T y);
  template<class T>
    constexpr T div_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_to_odd(T x, T y);
  template<class T>
    constexpr T div_to_even(T x, T y);
  template<class T>
    constexpr T div_ties_to_zero(T x, T y);
  template<class T>
    constexpr T div_ties_away_zero(T x, T y);
  template<class T>
    constexpr T div_ties_to_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_odd(T x, T y);
  template<class T>
    constexpr T div_ties_to_even(T x, T y);

  template<class T>
    constexpr div_result<T> div_rem_to_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_away_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_neg_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_odd(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_even(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_away_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_odd(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_even(T x, T y);

  template<class T>
    constexpr T mod(T x, T y);}
}
}
}

\h3{[numeric.sat.func]}

Change \eelis{numeric.sat.func#9} as follows:

\diff{
\del{\expects} \ins{\constexpects}
\tcode{y != 0} is \tcode{true}.
}

Delete \eelis{numeric.sat.func#11}:

\delblock{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.   
}

\h3[id=new-subclause]{[numeric.int.div]}

Append a new subclause to \eelis{numeric.ops},
following \eelis{numeric.sat}:

\insblock{
\html-h2{Integer division \stable-ref{numeric.int.div}}
\Vset[pnum]{0}

\macro[\div-returns{rounding}]{\returns \math{\mfrac{\mi{x}\mi{y}}}, rounded \put{}.}
\macro[\div-returns-nearest{rounding}]{
\returns \math{\mfrac{\mi{x}\mi{y}}}, rounded towards the nearest integer.
If two integers are equidistant, the result is \put{}.
}
\macro[\div-constraints]{\constraints
\tcode{T} is a signed or unsigned integer type\iref{basic.fundamental}.}

\itemdecl{
template<class T>
  constexpr T div_to_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards zero}\br
\wg21-note{
The result equals \tcode{x / y}.
}
}

\itemdecl{
template<class T>
  constexpr T div_away_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{away from zero}
}

\itemdecl{
template<class T>
  constexpr T div_to_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards positive infinity}
}

\itemdecl{
template<class T>
  constexpr T div_neg_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards negative infinity}
}

\itemdecl{
template<class T>
  constexpr T div_to_odd(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards the nearest odd integer}
}

\itemdecl{
template<class T>
  constexpr T div_to_even(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns{towards the nearest even integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the integer with lower magnitude}
}

\itemdecl{
template<class T>
  constexpr T div_ties_away_zero(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the integer with greater magnitude}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the greater integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_neg_inf(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the lower integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_odd(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the odd integer}
}

\itemdecl{
template<class T>
  constexpr T div_ties_to_even(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\div-returns-nearest{the even integer}
}

\itemdecl{
template<class T>
  constexpr div_result<T> div_rem_\exposid{rounding}(T x, T y);
}

\itemdescr{
\pnum
\div-constraints

\pnum
\constexpects
\tcode{x / y} is well-defined.

\pnum
\returns
A result object where
\ul[style=margin:0]{
\li{\tcode{quotient} is the quotient \math{\mi{q}} returned by \tcode{div_\exposid{rounding}(x, y)} and}
\li{
\tcode{remainder} is an integer \math{\mi{r}},
so that \math{\mrow{\mi{r}\mo{=}\mi{x}\mo{\N{MINUS SIGN}}\mi{q}\mi{y}}}.
}
}
\wg21-note{
It is possible for \tcode{div_\exposid{rounding}(x, y)} to have well-defined behavior even when
\tcode{x - quotient * y} has undefined behavior.
\br\wg21-example{
Assume that \tcode{\hl[macro]{INT_MAX}} equals \tcode{2'147'483'647}.
\itemdecl{
const auto q_to_zero = \hl[macro]{INT_MAX} / 2;              // \serif{\tcode{q_to_zero} is \tcode{1'073'741'823}.}
const auto [q, r] = div_rem_to_inf(\hl[macro]{INT_MAX}, 2);  // \serif{\tcode{q} is \tcode{1'073'741'824} and \tcode{r} is \tcode{-1}.}
int r2 = x - q * 2;                              // \serif{This multiplication has undefined behavior.}
}
}}
}

\itemdecl{
template<class T>
  constexpr T mod(T x, T y);
}

\itemdescr{
\pnum
\effects
Equivalent to \tcode{div_rem_to_neg_inf(x, y).remainder}.
\br\wg21-note{
The result is negative if and only if \tcode{y} is negative and \tcode{x} is nonzero.
}
}

}

\warning{
If the mathematical notation in the block above does not render for you,
you are using an old browser with no MathML support.
Please open the document in a recent version of Firefox or Chrome.
}

\h3{[simd.bit]}

Change \eelis{simd.bit#4} as follows:

\diff{
\del{\expects} \ins{\constexpects}
For every \math{\mi{i}} [\N{HORIZONTAL ELLIPSIS}].
}

Delete \eelis{simd.bit#6}:

\delblock{
\remarks
A function call expression that violates the precondition in the \expects element
is not a core constant expression\iref{expr.const}.   
}

\h2{References}

\bib[
    id = N5008,
    title = Working Draft\, Programming Languages â€” C++,
    date = 2025-03-15,
    author = Thomas KÃ¶ppe,
    link = https://wg21.link/n5008,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf
]
\bib[
    id = P0105R1,
    title = Rounding and Overflow in C++,
    date = 2017-02-05,
    author = Lawrence Crowl,
    link = https://wg21.link/p0105r1,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0105r1.html
]
\bib[
    id = P1889R1,
    title = C++ Numerics Work In Progress,
    date = 2019-12-27,
    author = Alexander Zaitsev,
    link = https://wg21.link/p1889r1,
    long-link = https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1889r1.pdf
]
\bib[
    id = StackOverflowDivision,
    title = Fast ceiling of an integer division in C / C++,
    link = https://stackoverflow.com/q/2745074/5740428
]
\bib[
    id = BuggyDivisions,
    author = njohnny84,
    title = Rounding Modes For Integer Division,
    link = https://blog.demofox.org/2022/07/21/rounding-modes-for-integer-division/
]
\bib[
    id = CompilerExplorerRemQuo,
    author = Jan Schultke,
    link = https://godbolt.org/z/vTPq9eGP6
]

\make-bib

\h2[id=implementation]{Appendix A \N{EM DASH} Reference implementation}

\macro[\sgn2]{\exposid{sgn}}

\cppblock{\include{intdiv.cpp}}

\note{
Since integer division occurs unconditionally in these functions,
they also trivially satisfy the \ref[#wording] requirement that invocations of these functions
are not constant expressions when the result is not representable.
}

\comment{https://godbolt.org/z/71sffK8ob}
